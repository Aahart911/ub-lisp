<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Краткий курс по Common Lisp'у</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Краткий курс по Common Lisp'у"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-12-09T17:23+0400"/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Краткий курс по Common Lisp'у</h1>

<p><i>Университет Буффало - Университет штата Нью-Йорк</i>
</p>
<p>
<b>Факультет компьютерных и инженерных наук</b>
</p>


<hr/>

<p>
© 2004 Стюарт Шапиро, Дэвид Пирс. Все права защищены.
</p>
<dl>
<dt>План</dt><dd>

<ol>
<li>Ресурсы о Common Lisp'е

<ul>
<li><a href="http://filonenko-mikhail.github.com/cltl2-doc/">Язык Common Lisp от Гая Стила (пер. на русский)</a>
</li>
<li><a href="http://lisper.ru/pcl/">Practical Common Lisp Peter Seibel (пер. на русский)</a>

</li>
<li><a href="http://www.franz.com/support/documentation/8.1/doc/">Index to all Allegro CL version 8.1 symbols</a>
</li>
<li><a href="http://www.franz.com/support/documentation/8.1/ansicl/ansicl.htm">ANSI Common Lisp</a>
</li>
<li>The <a href="http://www.lispworks.com/documentation/HyperSpec/Front/"><i>Common Lisp HyperSpec</i></a>
</li>
<li>Stuart C. Shapiro, <a href="http://www.cse.buffalo.edu/~shapiro/Commonlisp/">Common Lisp: An Interactive Approach</a>,
       W. H. Freeman, New York,
</li>
<li>On-line <a href="http://www.cse.buffalo.edu/~shapiro/Courses/CSE202/Notes/">Course Notes</a> from CSE202 of Fall 2000 to accompany the
       book <a href="http://www.cse.buffalo.edu/~shapiro/Commonlisp/">Common Lisp: An Interactive Approach</a>. (Note: this course
       is not currently operating)

</li>
</ul>

</li>
<li>Common Lisp'овые средства разработки

<dl>
<dt>Для редактирования, тестирования и отладки: </dt><dd>
<ul>
<li>Скачайте emacs для вашей операционной системы.
</li>
<li>Установите реализацию Common Lisp'а (sbcl, clozure cl)
</li>
<li>Установите Quicklisp
</li>
<li>Загрузите quicklisp-slime-helper следующей lisp формой:
         (ql:quickload :quicklisp-slime-helper)
</li>
<li>Добавьте в файл ~/.emacs

<blockquote>




<pre class="example">(load (expand-file-name "~/quicklisp/slime-helper.el"))
;; Замените "sbcl" на путь к реализации Common Lisp'а
(setq inferior-lisp-program "sbcl")
</pre>


</blockquote>


</li>
</ul>

</dd>
<dt>Для редактирования файлов:</dt><dd>

<ol>
<li>Используйте расширение <code>.lisp</code>
</li>
<li>Используйте режим Common Lisp'а
</li>
<li>Учите команды этого режима с помощью <code>C-h m</code>

</li>
</ol>

</dd>
<dt>Для тестирования и отладки: </dt><dd>

<ol>
<li><code>M-x slime</code>
</li>
<li>Это РЕПЛ &ndash; оболочка, в которой можно выполнять Lisp'овый код.
</li>
<li>Учите команды интерактивной Common Lisp'овой среды с помощью <code>C-h m</code>

</li>
</ol>

</dd>
</dl>

</li>
<li>Lisp'овый стиль программирования

<ul>
<li>Ориентирован на выражения: Последовательное вычисление выражений.
</li>
<li>Можно считывать выражения из файла, можно их сразу писать в стандартный ввод.
</li>
<li>Lisp'овая машина.
</li>
<li>Цикл чтение-выполнение-вывод.

</li>
</ul>

</li>
<li>Числа

<ul>
<li>Числа являются атомами, которые вычисляются сами в себя.
</li>
<li>Попробуйте цикл чтение-выполнение-вывод. Ну правда, всё
       просто:

<ol>
<li>Чтение
</li>
<li>Создание объекта
</li>
<li>Выполнение объекта
</li>
<li>Выбор текстового представления объекта
</li>
<li>Вывод

</li>
</ol>

</li>
<li>Три сюрприза:

<ol>
<li>большие числа (bignums)
</li>
<li>дроби (ratios)
</li>
<li>комплексные числа

</li>
</ol>

</li>
</ul>

</li>
<li>Неатомные выражения

<ul>
<li>Кембриджская префиксная нотация

</li>
</ul>

</li>
<li>Emacs'овый буфер <code>*scratch*</code> находится в режиме исполнения
     Lisp'ового кода. Нажмите Ctrl-j после Lisp'овой формы.

</li>
<li>Выход: (exit) в Lisp'овом режиме.

</li>
<li>Логические (булевы) значения

<ul>
<li>Lisp'овая Ложь это <code>nil</code> (пустой список) - атом, который
       вычисляется сам в себя.
       Попробуйте сами. 

</li>
<li>Lisp'овая Истина это <code>t</code> (символ <code>t</code>) - атом, который вычисляется сам в
       себя. <i>Любой другой Lisp'овый объект кроме =nil=, также является        истиной</i>.

</li>
<li><code>and</code> и <code>or</code> являются Lisp'овыми <i>макросами</i>,
       которые принимают любое количество аргументов, и лениво их вычисляют.
       Попробуйте сами указывая разное количество аргументов.
       Попробуйте вызвать их вообще без аргументов.
       Эти макросы возвращают <code>t</code>, <code>nil</code> или значение последнего вычисленного выражения.

</li>
</ul>

<p>     Упражнение: Создайте файл для Lisp'ового кода. Теперь в начале
      просто наберите несколько комментариев с указанием задач
     данного файла.
</p>
</li>
<li>Комментарии

<blockquote>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left"><code>;</code></td><td class="left">В конце строки</td><td class="left">В строке после кода</td></tr>
<tr><td class="left"><code>;;</code></td><td class="left">Во всю строку</td><td class="left">Отступ как у кода</td></tr>
<tr><td class="left"><code>;;;</code></td><td class="left">Во всю строку</td><td class="left">В начале строки</td></tr>
<tr><td class="left"><code>#\vert ... \vert#</code></td><td class="left">Скобки для многострочных комментариев</td><td class="left">Для комментирования блоков кода</td></tr>
</tbody>
</table>


</blockquote>


</li>
<li>Создание функций

<ul>
<li>Изучите раздел о макросе <code>defun</code>

</li>
<li>Например

<blockquote>




<pre class="example">(defun average (x y)
  "Возвращает среднее арифметическое для чисел x и y."
  ;; Не округляет и не сокращает целые числа
  (/ (+ x y) 2))
</pre>


</blockquote>


</li>
<li>Переменные имеют лексическое пространство.

</li>
<li>Тип имеют объекты, а не переменные.

</li>
<li>Загрузите файл:
         <code>(load "file-name")</code> в РЕПЛе
         или <code>C-c C-l</code> в буфере с исходным кодом

</li>
<li>Упраженение: Создайте <code>(discrim a b c)</code>, которая
        возвращает квадратный корень выражения <code>b2 - 4ac</code>
         <code>(discrim 2 7 5)</code> должна вернуть <code>3.0</code>

</li>
<li>Сюрприз в том, что Lisp'овые функции могут возвращать
        несколько значений
         Попробуйте <code>(floor 5.25)</code> или <code>(round 5.25)</code>

</li>
<li>Например

<blockquote>




<pre class="example">(defun +- (x d)
  "Возвращает x+d и x-d."
  (values (+ x d)
      (- x d)))
</pre>


</blockquote>


<p>
        Попробуйте: <code>(values)</code>
</p>
</li>
<li>Упражнение: Используя <code>discrim</code>, определите <code>(quad-roots a b c)</code>
        для возврата корней квадратного уравнения

<blockquote>

<p>ax<sup>2</sup> + bx + c = 0
</p>
</blockquote>


<p>
        то есть, <code>(-b + sqrt(b2 - 4ac))/2a</code> и
        <code>(-b - sqrt(b2 - 4ac))/2a</code>
        <code>(quad-roots 2 7 5)</code> должна возвращать <code>-1.0</code> и <code>-2.5</code>
</p>
</li>
</ul>

</li>
<li>Условное выполнение (две ветки)

<blockquote>

<p>        <code>(if test-form then-form [else-form])</code>
</p>
<p>
        Заметьте: <code>if</code> является специальной формой
</p>
<p>
        Например:
</p>



<pre class="example">(defun fact (n)
  "Возвращает факториал от n"
  (if (&lt;= n 0)
      1
    (* n (fact (1- n)))))
</pre>


<p>
        Упражнение: Создайте <code>(fibonacci n)</code>, которая возвращает n-ое число Фибоначи:
         1 1 2 3 5 8 13 &hellip;
</p>
</blockquote>


</li>
<li>Трассировка

<p>       
       <code>(trace function-name ... function-name)</code> включает трассировку
      указанных функций. 
       <code>(trace)</code> возвращает список трассируемых
      функций.
       <code>(untrace function-name ... function-name)</code> выключает
      трассировку указанных функций
       <code>(untrace)</code> выключает все трассировки.
</p>
<p>       
      Когда курсор находится на названии функции нажмите <code>C-c t</code>, и
      для этой функции включится трассировка.
</p>
<p>
      Включите трассировку для функций <code>discrim</code> и <code>quad-root</code> и
      при их вызовах посмотрите, что будет. Затем выключите трассировку.
</p>
</li>
<li>Строковые символы

<ul>
<li>Строковые символы, как и числа, это "атомы, которые
        вычисляются в себя". Их синтаксис #/&lt;имя символа&gt;/. Попробуйте сами:

<blockquote>




<pre class="example">#\a
#\space
#\newline
</pre>


</blockquote>



</li>
<li>Lisp умеет Unicode, поэтому можно делать так.

<blockquote>




<pre class="example">#\cyrillic_small_letter_a
#\cyrillic_small_letter_je
#\latin_small_letter_eth
#\greek_capital_letter_sigma
</pre>


</blockquote>



</li>
<li>Теперь выполните следующий код:

<blockquote>




<pre class="example">(format t "~a" #\latin_small_letter_a_with_acute)
</pre>


</blockquote>


<p>
        <code>Format</code> это Lisp'овый эквивалент функции <code>printf</code>, только,
        конечно, (ГОРАЗДО!) более мощный. Мы поговорим подробнее о
        нём позже, но для начала, <code>format t</code> просто выводит
        результат в стандартный вывод, и <code>~a</code> указывает, что
        напечатанный объект должен быть человекочитаемым.
</p>
<p>
        Lisp может выводить Unicode символы, но Emacs'у это сделать
        сложнее, поэтому можно вывести код символа с помощью <code>char-code</code>:
</p>
<blockquote>




<pre class="example">(char-code #\greek_capital_letter_sigma)
</pre>


</blockquote>


</li>
<li>Для сравнения строковых символов используйте <code>char</code>, <code>char&lt;</code>, <code>char&gt;</code>.

</li>
</ul>

</li>
<li>Строки

<ul>
<li><i>Строки</i> также являются атомами, которые вычисляются в себя, и
        указываются как последовательность символов между двойными
        кавычками.

</li>
<li>Создание строк:

<blockquote>




<pre class="example">"вот строка"
(char "вот строка" 0)
(char "вот строка" 2)
"строка с таким \" знаком"
(char "строка с таким \" знаком" 11) 
(char "строка с таким \" знаком" 12) 
(char "строка с таким \" знаком" 13)
(format t "~a" "строка с таким \" знаком")
(string #\latin_small_letter_a_with_acute)
(string-capitalize "дэвид.р.пирс")
(string-trim "as" "sassafras")
            
</pre>


</blockquote>


</li>
<li>Сравнение строк:

<blockquote>




<pre class="example">(string= "дэвид пирс" "Дэвид Пирс")
(string-equal "дэвид пирс" "Дэвид Пирс")
(string&lt; "Дэвид Пирс" "Стью Шапиро")
(string/= "foobar" "foofoo")
            
</pre>


</blockquote>


</li>
<li>Строки как последовательности:

<blockquote>




<pre class="example">(length "просто строка")
(length "\\")
(format t "~a" "\\")
(subseq "просто строка" 3)
(subseq "просто строка" 3 6)
(position #\space "просто строка")
(position #\i "Дэвид Пирс")
(position #\i "Дэвид Пирс" :start 5)
(search "pi" "дэвид пирс и стью шапиро")
(search "pi" "дэвид пирс и стью шапиро" :start2 10)
(concatenate 'string "foo" "bar")
(concatenate 'string
  "d" (string #\latin_small_letter_a_with_grave)
  "v" (string #\latin_small_letter_i_with_acute)
  "d")
</pre>


</blockquote>


</li>
<li>Упражнение: Определите <code>(string-1+ s)</code>, которая создаёт
        новую строку, прибавляя 1 к каждому коду символа старой
        строки. Например, =(string-1+ "a b c") =&gt; "b!c!d"=.

</li>
</ul>

</li>
<li>Символы

<ul>
<li>Символ является атомом, который может иметь, а может и не
        иметь значение.

</li>
<li>Синтаксис:
        почти любая последовательность строковых символов (в разных
        регистрах), которая не может быть числом.
         (Внимание: в некоторых старых реализациях Lisp'а,
        считыватель возводит в верхний регистр все строковые
        символы, даже если они были экранированы.)

</li>
<li>Экранирующий строковый символ: <code>\</code>
</li>
<li>Экранирующие скобки: <code>| ... |</code>
</li>
<li>Аттрибуты символа

<ol>
<li><code>symbol-name</code>
</li>
<li><code>symbol-value</code>
</li>
<li><code>symbol-function</code>
</li>
<li><code>symbol-package</code>
</li>
<li><code>symbol-plist</code>

</li>
</ol>

</li>
<li>Квотировние: '<code>expression</code> всегда вычисляется в
        <code>expression</code>, а не в значение символа <code>expression</code>

</li>
<li>Загрузите ваш файл с исходным кодом функции <code>average</code>
          Попробуйте следующие формы:




<pre class="example">(type-of 'average)
(symbol-name 'average)
(type-of (symbol-name 'average))
(symbol-function 'average)
#'average
(type-of #'average)
(type-of (type-of #'average))
(function-lambda-expression #'average)
</pre>


</li>
<li>Поместите ваш курсор в буфер и нажмите <code>C-x 1</code>.
        Перейдите на слово <code>average</code> нажмите C-c C-d C-d.

</li>
<li>Функция для проверки равенства символов:
        <code>eql</code>
        Попробуйте сами.

</li>
<li>Как Lisp'овый считыватель узнаёт откуда символ, который вы только
        что напечатали?

<ol>
<li>Считывает все напечатанные строковые символы,
           конструирует строку (имя символа).
</li>
<li>Ищет атом по имени в "каталоге" (возможно в хеш-таблице).
</li>
<li>Если его там нет, создаёт его, и туда кладёт.

</li>
</ol>

<p>        Процесс установки символа в каталог называется
        <i>пакетирование</i>, символ который был инсталлирован <i>пакетный         символ</i>.
</p>
</li>
</ul>

</li>
<li>Пакеты

<p>
      Пакет является каталогом (отображением) имя символа =&gt;
      символ, другими словами, "пространством имён".
       Всегда имеется текущий пакет, который Lisp'овый считыватель
      использует для поиска имён символов.
       Попробуйте выполнить <code>*package*</code> в РЕПЛе.
</p>
<p>
      Lisp'овые пакеты никак не связаны с директориями или
      файлами. Обычно каждый файл в свою очередь наполняет явно
      указанный пакет.
</p>
<p>
      Пакетированный символ в пакета может быть <b>внутренним</b>
      или <b>внешним</b>, и данный пакет для символа рассматривается
      как <b>домашний пакет</b>.
      Найти домашний пакет для символа можно формой <code>(symbol-package       symbol)</code>
      Попробуйте <code>(symbol-package 'average)</code> и <code>(symbol-package 'length)</code>
</p>
<p>
      У каждого пакета есть имя, и также может быть один или
      несколько псевдонимов.
      Попробуйте: <code>(package-name (symbol-package 'average))</code>
      и <code>(package-nicknames (symbol-package 'average))</code>
</p>
<p>       
      Связь между пакетами и их псевдонимами:
</p>
<blockquote>

<p><code>(find-package package-name-or-symbol)</code>
 <code>(package-name package)</code>
 <code>(package-nicknames package)</code>
</p>
</blockquote>


<p>
      Выполните <code>(describe 'average)</code> Вы уже можете понять всё, что
      было получено этой формой.
</p>
<p>
      Выполните <code>(describe 'length)</code> Обратите внимание сколько было
      получено пакетов.
</p>
<p>
      Поместите курсор над символом или в РЕПЛе или в файле с
      Lisp'овым кодом, и нажмите <code>C-c С-d С-d</code>, затем <code>RET</code> в минибуфере.
</p>
<p>
      Попробуйте <code>(documentation 'average 'function)</code>
</p>
<p>
      Автодополнение символов: <code>M-TAB</code>
</p>
<p>
      Вы можете сделать символ внешним в домашнем пакете с
      помощью формы <code>export</code>.
      Попробуйте <code>(export 'average)</code>.
      А теперь опять <code>(describe 'average)</code>.
</p>
<p>       
      Вы можете изменить пакет с помощью формы <code>in-package</code>.
       Попробуйте <code>(in-package :common-lisp)</code>
</p>
<p>
      Вы можете сослаться на символ с домашним пакетом <code>p</code> из
      какого-либо другого пакета, вне зависимости от того является
      ли символ внешним.
       Для ссылки на внешний символ <code>s</code> из пакета <code>p</code> наберите <code>p:s</code>
       Для ссылки на внутренний символ <code>s</code> из пакета <code>p</code> наберите <code>p::s</code>
</p>
<p>
      Попробуйте сами:
</p>
<blockquote>




<pre class="example">'cl-user::discrim
'cl-user::average
'cl-user:average
'cl-user::length
'discrim
</pre>


</blockquote>


<p>
      Обратите внимание на печатное представление, которое Lisp
      выбирает для этих символов.
      Обратите внимание, что последняя строка указывает Lisp'у
      создать символ с именем ="discrim"= в пакете <code>common-lisp</code>.
</p>
<p>
      Для перехода обратно в пакет common-lisp-user наберите:
      <code>(in-package :common-lisp-user)</code>
</p>
<p>
      Попробуйте сами
</p>
<blockquote>




<pre class="example">'cl-user::discrim
'cl::discrim
(symbol-name 'discrim)
(symbol-name 'cl::discrim)
(string= (symbol-name 'discrim) (symbol-name 'cl::discrim))
(eql 'discrim 'cl::discrim)
</pre>


</blockquote>


<p>
      Не смущайтесь того, что <code>discrim</code> и <code>cl::discrim</code> это <i>разные</i>
      символы, просто у них одинаковое имя.
</p>
<p>
      <b>Два специальных пакета</b>
</p>
<ol>
<li>Пакет ключевых символов

<p>          
         Каждый символ в этом пакете является внешним и вычисляется
         сам в себя.
</p>
<p>
           Этот символ создаётся с помощью пустого имени пакета и
         одинарного двоеточия <code>:</code> Попробуйте <code>(describe :foo)</code>
</p>
</li>
<li>Непакет

<p>
         Если считыватель видит строку вида <code>#:s</code>, он
         создаёт <b>беспакетный</b> символ с именем ="s"=, то есть символ,
         у которого нет домашнего пакета.
           Безпакетный символ не может быть найден Lisp'овым
         считывателем, и таким образом беспакетные символы никогда
         не равны <code>eql</code> друг другу, даже если у них одинаковые имена.
</p>
<p>
         Попробуйте:
</p>
<blockquote>




<pre class="example">(describe '#:foo)
(eql '#:foo '#:foo)
(string=  (symbol-name '#:foo) (symbol-name '#:foo))
</pre>


</blockquote>


<p>
         Выполните <code>(gensym)</code>. <code>gensym</code> создаёт новые беспакетные
         символы.
</p>
</li>
</ol>

<p>      <b>Создание пакетов</b>
</p>
<p>
      Самый простой путь создания пакета это форма <code>(defpackage       package-name)</code>, где <code>package-name</code>, не вычисляется и должно
      быть строкой или символом (в последнем случае используется имя
      символа). Мы рекомендуем использовать ключевой символ,
      например, <code>(defpackage :test)</code>.
</p>
<p>
      Посмотрите на буфер в Emacs'е, в котором вы выполняли
      упражнения. В модлайне будет указан пакет для данного буфера.
</p>
<p>
      Введите форму <code>(defpackage :test)</code> в самом начале файла, прямо
      сразу за комментариями.
</p>
<p>
      Мы хотим, чтобы символы в этом файлы были спакетированы в пакет
      <code>test</code>. Это значит надо изменить текущий пакет на <code>test</code>, чтобы
      считыватель ориентировался на него. Выполните
      <code>(in-package :test)</code> сразу после формы определения
      пакета. Макрос <code>in-package</code> принимает строку или символ. Мы
      рекомендуем использовать ключевой символ.
</p>
<p>
      Когда Lisp загружает файл, он сохраняет, а затем
      восстанавливает <code>*package*</code>. Поэтому после загрузки файла вам
      не надо вызывать <code>in-package</code> для возврата в ваш пакет.
</p>
<p>
      Вопрос: Находился ли Lisp'овый считыватель в пакете
      <code>exercises</code> при чтении форм в вашем файле?
</p>
<p>
      Сделайте символы определённые в вашем пакете <code>exercises</code>
      внешними:
        Измените форму 
</p>
<blockquote>

<p><code>(defpackage :exercises)</code>
</p>
</blockquote>


<p>
      на
</p>
<blockquote>




<pre class="example">(defpackage :exercises
        (:export #:average #:discrim #:fact #:quad-roots #:string-1+))
</pre>


</blockquote>


<p>
      Сохраните эту версию файла, перезагрузите Lisp, загрузите
      файл и попробуйте использовать функции уже из
      <code>common-lisp-user</code> пакета.
</p>
<p>
      <b>Использование пакетов</b>
</p>
<p>
      Пакет может <b>использовать</b> другой пакет. В этом случае, все
      внешние символы используемого пакеты в первом пакете будут
      доступны без указания родительского пакета.
</p>
<p>
      Например, пакет <code>common-lisp-user</code> использует пакет
      <code>common-lisp</code>, поэтому мы можем вызвать функцию length без
      указания пакета <code>common-lisp</code>.  
       Посмотреть на это глазами можно с помощью формы <code>(package-use-list :user)</code>.
</p>
<p>
      В РЕПЛе, в пакете <code>user</code> выполните форму
      <code>(use-package :exercises)</code>. Теперь вызывайте функции без
      указания домашнего пакета.
</p>
<p>       
      <b>Скрытие символов</b>
</p>
<p>
      Упражнение: В вашем файле, определите функцию <code>last</code>, которая
      принимает строку и возвращает её последний символ.
</p>
<p>
      Вы не можете это сделать, потому что <code>last</code> это имя функции,
      которая определена в пакете <code>common-lisp</code>, вы неможете её
      переопределить.
</p>
<p>
      В пакете <code>common-lisp</code> много символов. Должны ли вы избегать
      коллизий с ними всеми? Нет!
</p>
<p>
      Измените текущий пакет в РЕПЛе на <code>exercises</code>, и скройте
      символ <code>cl:last</code> с помощью <code>(shadow 'last)</code>, и затем наберите
      ваше определение функции в РЕПЛе. Проверьте результат.
</p>
<p>
      Добавьте ваше определение <code>last</code> в ваш файл с исходным кодом,
      и добавьте форму <code>(:shadow cl:last)</code> в форму
      <code>defpackage</code>. Также добавьте символ <code>last</code> в список
      экспортируемых (внешних) символов.
</p>
<p>
      Перезапустите Lisp, загрузите файл. Проверьте функцию <code>last</code>.
</p>
<p>
      Попробуйте <b>использовать</b> пакет <code>exercises</code> в пакете
      <code>user</code>. Возникнет конфликт. Будет задан вопрос, о том, какой
      из символов <code>cl:last</code> или <code>exercises:last</code> нужно использовать.
</p>
</li>
<li>Списки и Cons-ячейки

<p>
      Список является фундаментальной структурой данных в Lisp'е, от
      которой и получил своё название язык (LISt Processing).
</p>
<p>
      Список является объектом, который хранит последовательность
      элементов, которые могут быть или ссылаться на Lisp'овые
      объекты. Синтаксис списков такой: (<i>a</i>
      <i>b</i> <i>c</i> &hellip;). Списки создаются с помощью формы list.
</p>
<blockquote>




<pre class="example">'()
'(1 2 3)
(list 1 2 3)
</pre>


</blockquote>


<p>
      Заметьте, что Lisp выводит пустой список ='()= как
      <code>nil</code>. Символ <code>nil</code> помимо значения Ложь, означает пустой список.
</p>
<p>
      Упражнение: Создайте список содержащий два списка <code>(1 2 3)</code>
      и <code>(4 5 6)</code>.
</p>
<p>
      Доступ к элементам:
</p>
<blockquote>




<pre class="example">(first '(1 2 3))
(second '(1 2 3))
(third '(1 2 3))
(nth 5 '(1 2 3 4 5 6 7 8 9 10))
(rest '(1 2 3))
(rest (rest '(1 2 3)))
(nthcdr 0 '(1 2 3 4 5 6 7 8 9 10))
(nthcdr 5 '(1 2 3 4 5 6 7 8 9 10))
</pre>


</blockquote>


<p>
      Работа со списками:
</p>
<blockquote>




<pre class="example">(endp '())
(endp '(1 2 3))
(endp nil)
(endp ())
(listp '())
(listp '(1 2 3))
(eql '(1 2 3) '(1 2 3))
(equal '(1 2 3) '(1 2 3))
(length '(1 2 3))
(append '(1 2 3) '(4 5 6))
(member 3 '(1 2 3 4 5 6))
(last '(1 2 3 4 5 6))
(last '(1 2 3 4 5 6) 3)
(butlast '(1 2 3 4 5 6))
(butlast '(1 2 3 4 5 6) 3)
</pre>


</blockquote>


<p>
      Списки также являются последовательностями.
</p>
<p>
      Упражнение: Напишите функцию <code>(reverse l)</code>, которая возвращает
      список, содержащий элементы списка <i>l</i> в обратном
      порядке. (Common Lisp уже содержит функцию с таким именем,
      поэтому вам нужно вновь разрешить конфликт имён.)
</p>
<p>
      Базовый строительный объект списка называется
      "cons-ячейка". Cons-ячейка это объект, которые содержит два
      элемента. Элементы называются <i>car</i> и <i>cdr</i> (по историческим
      причинам). Синтаксис cons-ячейки выглядит так: 
</p>
<blockquote>




<pre class="example">(object1 . object2) 
</pre>


</blockquote>


<p>
      Cons-ячейки обычно используются для создания (связного) списка.
</p>
<blockquote>




<pre class="example">(object1 . (object2 . (object3 . (object4 . nil))))
</pre>


</blockquote>


<p>
      Когда мы используем cons-ячейки для построения списков, мы
      будет часто ссылаться на элементы как на <i>первый</i> и
      <i>оставшийся</i>, или как на <i>головной</i> и <i>хвостовой</i>. Список
      список, которого последний <i>cdr</i> элемент не <code>nil</code>, называется
      списком с точкой (например, <code>(1 2 . 3)</code>). "Правильный список"
      в последнем <i>cdr</i> содержит <code>nil</code>. Функция <code>cons</code> создаёт
      cons-ячейку. Так как списки состоят из cons-ячеек функция cons
      также используется для добавления элементов в начало списка.
</p>
<p>
      Работа с cons-ячейками:
</p>
<blockquote>




<pre class="example">(cons 1 2)
(cons 1 nil)
'(1 . nil)
(cons 1 '(2 3))
(consp '(1 . 2))
(car '(1 . 2))
(cdr '(1 . 2))
(first '(1 . 2))
(rest '(1 . 2))
</pre>


</blockquote>


<p>
      Между прочим, cons-ячейки могут использоваться для создания
      бинарных деревьев.
</p>
<blockquote>




<pre class="example">(root . ((child1 . leaf1) . (child2 . ((child3 . leaf3) leaf2))))
</pre>


</blockquote>


<p>
      Упражнение: Создайте бинарное дерево как на картинке.
</p>
<p>
      Упражнение: Определите функцию <code>(flatten2 binary-tree)</code>,
      которая возвращает элементы дерева <i>binary-tree</i>.
</p>
<p>
      Более того, правильные списки могут использоваться для
      создания деревьев с произвольным количеством дочерних
      узлов. Например, ((a (b) c) (d ((e)) () f)).
</p>
</li>
<li>Условные переходы (одна ветка)

<p>
      <code>If</code> может использоваться без <i>else</i> ветки. В этом случае, <i>else</i>
      ветка неявно возвращает <code>nil</code>. Однако лучше использовать формы
      <code>when</code> и <code>unless</code>. В частности <code>(when test expression...)</code>,
      вычисляет <i>test</i>, и если условие истинно, вычисляет оставшиеся
      выражения, возвращая результат последнего, если условие ложно
      возвращает <code>nil</code>. Так же <code>(unless test expression...)</code>
      вычисляет выражения, если <i>test</i> ложно.
</p>
<p>
      Между прочим, многие Lisp'овые формы принимают
      последовательность выражений и возвращают результат последнего
      из них. Сюда входят <code>defun</code>, <code>when</code>, <code>unless</code> и <code>cond</code>, который будут
      рассмотрены далее. Часто говорится, что такие формы содержат
      "неявный <code>progn</code>". 
</p>
<p>
      Условные переходы с одной веткой полезны, в частности,
      тогда. когда по-умолчанию значение для вычисления <code>nil</code>. Например:
</p>
<blockquote>




<pre class="example">(defun member (x list)
  "Возвращает истину, если x содержится в списке list."
  (when list
    (or (eql x (first list)) (member x (rest list)))))
</pre>


</blockquote>


<p>
      Упражнение: Напишите функцию <code>(get-property x list)</code>, которая
      возвращает элемент список <i>list</i> сразу за элементом <i>x</i>, или
      <i>nil</i>, если <i>x</i> в списке <i>list</i> не содержится. Например,
      <code>(get-property 'name '(name david office 125)) =&gt; david</code>.  (Для
      решения задачи может пригодится функция <code>member</code>, которая не
      просто возвращает <code>t</code>, когда находит <i>x</i> в списке. Вы можете
      также не использовать функцию <code>when</code>, но ради интереса,
      попробуйте и с ней.) Список такого вида, который используется в
      этой функции называется списком свойств. Существуют похожие
      встроенные функции <code>getf</code> и <code>get-properties</code>, они отличаются
      только порядком аргументов.
</p>
</li>
<li>Условные переходы (несколько веток)

<p>
      Форма многоветочного условного перехода выглядит так:
</p>
<blockquote>




<pre class="example">(cond
 (expression11 expression12 ...)
 (expression21 expression22 ...)
 ...
 (expressionn1 expressionn2 ...))
</pre>


</blockquote>


<p>
      Выражение <code>expressioni1</code> вычисляется начиная с <i>i = 1</i> пока одно
      из них не возвратит не-=nil= значение. В этом случае
      вычисляется оставшаяся часть группы, и возвращается значение
      последнего выражения. Если все выражения <code>expressioni1</code>
      вернули <code>nil</code>, тогда значение формы <code>cond</code> также <code>nil</code>. Часто
      встречается что значение всего выражения это значение
      последнего выполненного подвыражения.
</p>
<p>
      Чаще всего, <code>cond</code> рассматривается так:
</p>
<blockquote>




<pre class="example">(cond
 (test1 expression1 ...)
 (test2 expression2 ...)
 ...
 (testn expressionn ...))
</pre>


</blockquote>


<p>
      Последнее выражение <i>test</i> может быть <code>t</code>, тогда последняя
      ветка является веткой по-умолчанию.
</p>
<blockquote>




<pre class="example">(defun elt (list index)
  "Возвращает элемент списка в позиции /index/, или =nil=, если данной позиции не было."
  (cond
   ((endp list)
    nil)
   ((zerop index)
    (first list))
   (t
    (elt (rest list) (1- index)))))
</pre>


</blockquote>


<p>
      Упражнение: Создайте функцию <code>(flatten tree)</code>, которая
      принимает список, который представляет дерево, с произвольным
      количеством веток, и возвращает список, в котором перечислены
      все элементы дерева. Например:
      <code>(flatten '((a (b) c) () (((d e))))) =&gt; (a b c d e)</code>.
</p>
<p>
      Другим видом многоветочных условных выражений является форма
      case.
      Case выбирает ветку для исполнения в зависимости от значения
      заданного выражения (в других языках это называется "switch").
      Например, представим, что попросили пользователя загадать число:
</p>
<blockquote>




<pre class="example">(case (read)
  (2 "прости друг, слишком мало")
  (3 "в яблочко!!")
  (4 "прости, слишком много")
  (t "сдался?!"))
</pre>


</blockquote>


<p>
      Форму case можно примерно представить в виде формы <code>cond</code>.
</p>
<blockquote>




<pre class="example">(case expression
  (literal1 result1)
  (literal2 result2)
  ...
  (literaln resultn))
</pre>


<p>
        ≡
</p>



<pre class="example">(cond
  ((eql 'literal1 expression) result1)
  ((eql 'literal2 expression) result2)
  ...
  ((eql 'literaln expression) resultn))
</pre>


</blockquote>


<p>
      за исключением того, что <i>expression</i> вычисляется единожды.
      Как и в случае <code>cond</code>, последнее подвыражение может быть
      обозначено символом <code>t</code>, что сделает его, выражением
      по-умолчанию. Также заметьте, что в <code>case</code> форме ключ
      выражения не вычисляется, а следовательно его не нужно
      квотировать.
</p>
<p>
      В отличие от сишного выражения <code>switch</code>, Lisp'овая <code>case</code>
      может иметь несколько ключей для одной ветки, без
      использования функционала <code>break</code>. Например,
</p>



<pre class="example">(case (read)
  ((#\a #\e #\i #\o #\u) 'vowel)
  (#\y 'sometimes\ vowel)
  (t 'consonent))
</pre>


</li>
<li>Локальные переменные

<p>
      Помните функцию <code>quad-roots</code>?
</p>
<blockquote>




<pre class="example">(defun quad-roots (a b c)
  "Возвращает корни квадратного уравнения ax^2 + bx + c."
  (values (/ (+ (- b) (discrim a b c)) (* 2 a))
      (/ (- (- b) (discrim a b c)) (* 2 a))))
</pre>


</blockquote>


<p>
      Лучше было бы сэкономить время вычисления и сохранять
      промежуточные результаты в локальных переменных. Локальные
      переменные создаются с помощью формы <code>let</code>.
</p>
<blockquote>




<pre class="example">(defun quad-roots (a b c)
  "Возвращает корни квадратного уравнения ax^2 + bx + c."
  (let ((-b (- b))
        (d  (discrim a b c))
        (2a (* 2 a)))
    (values (/ (+ -b d) 2a) (/ (- -b d) 2a))))
</pre>


</blockquote>


<p>
      Основной вид формы <code>let</code>:
</p>
<blockquote>




<pre class="example">(let ((v1 e1)
      (v2 e2)
      ...
      (vn en))
  expression
  ...)
</pre>


</blockquote>


<p>
      Переменные с /v/<sub>1</sub> по /v/<sub>n</sub> будут связаны с результатами
      вычислений выражений с /e/<sub>1</sub> по /e/<sub>n</sub>. Эти связывания
      актуальны только для тела из выражений /expression/s. Как
      обычно результатом формы <code>let</code> является результат последнего
      выражения.
</p>
<p>
      <code>let</code> связывания ограничены лексически:
</p>
<blockquote>




<pre class="example">(let ((x 1))
  (list
    (let ((x 2))
      x)
    (let ((x 3))
      x)))
</pre>


</blockquote>


<p>
      <code>let</code> связывания выполняются параллельно:
</p>
<blockquote>




<pre class="example">(let ((x 3))
  (let ((x (1+ x))
        (y (1+ x)))
    (list x y)))
</pre>


</blockquote>


<p>
      <code>let*</code> связывания выполняются последовательно:
</p>
<blockquote>




<pre class="example">(let ((x 3))
  (let* ((x (1+ x))
         (y (1+ x)))
    (list x y)))
</pre>


</blockquote>


</li>
<li>Лябмда-списки.
      <i>Лямбда-списком</i> называется список формальных
      параметров, которые перечислены после имени функции в форме
      <code>defun</code>. Лямбда-списки, которые мы видели раньше, содержат
      только обязательные параметры, но фактически они могут
      содержать пять видов параметров, перечисленных ниже.

<dl>
<dt>Обязательные параметры </dt><dd>Обязательные параметры это
          обычные формальные параметры, к которым вы привыкли. Для
          каждого обязательного параметра может быть только один
          аргумент, и обязательные параметры связываются со
          значениями аргументов слева направо.

</dd>
<dt>Необязательные параметры </dt><dd>Необязательные параметры
          следуют за ключевым символом <code>&amp;optional</code>. Каждый
          необязательный параметр может выглядеть как:

<blockquote>

<p><code>var</code>
 <code>(var default-value)</code>
 или <code>(var default-value supplied-p)</code>
</p>
</blockquote>


<p>
        Если переданных аргументов больше чем обязательных
        параметров, лишняя часть аргументов будет связана с
        необязательными параметрами слева направо. Если
        необязательные параметры ещё остались, они будут связаны со
        значениями <code>default-value</code>, если такие значения указаны,
        или с <code>nil</code> в противном случае. Если был указан
        <code>supplied-p</code> и при вызове был аргумент для параметра, то
        <code>supplied-p</code> будет <code>t</code>, иначе <code>nil</code>.
          Например:
</p>
<ol>
<li>Заметьте, что функция <code>last</code> принимает необязательный
           аргумент.

</li>
<li>Попробуйте сами:

<blockquote>




<pre class="example">(defun testOpt (a b &amp;optional c (d 99 dSuppliedp))
  (list a b c d
        (if dSuppliedp '(supplied) '(default))))
(testOpt 2 3)
(testOpt 2 3 4 5)
</pre>


</blockquote>


</li>
</ol>

<p>        Упражнение: Переопределите ваши <code>reverse=/=reverse1</code> как
        одну функцию <code>reverse</code>, которая принимает один
        обязательный аргумент и один необязательный.
</p>
</dd>
<dt>Оставшиеся параметры </dt><dd>При использовании только обязательных
          и необязательных аргументов Lisp'овая функция ограничивается
          максимальным количеством фактических аргументов. Если
          лямбда-список содержит ключевой символ <code>&amp;rest</code>, то после
          него должен только один параметр, который при вызове
          будет содержать список всех значений фактических
          аргументов, которые были переданы после этого параметра.

<ol>
<li>Заметьте, что функция <code>-</code> требует один обязательный
           параметр и оставшиеся параметры, так что функция
           принимает один или более аргументов.

</li>
<li>Заметьте, что функция <code>and</code> принимает оставшиеся
           параметры, то есть принимает ноль или более аргументов.

</li>
<li>Попробуйте сами

<blockquote>




<pre class="example">(defun testRest (a b &amp;rest c)
  (list a b c))
(testRest 1 2)
(testRest 1 2 3 4 5 6)
</pre>


</blockquote>


</li>
</ol>

</dd>
</dl>

<p>      Упражнение: Функция <code>union</code> принимает два списка и
      возвращает список, который является объединением первых
      двух. Попробуйте сами. Создайте в своём пакете свою
      функцию <code>union</code>, которая принимает ноль и более
      аргументов в виде списков и используя <code>cl:union</code> верните
      объединение всех переданных списков.
</p>
<p>       
      Бонус: Lisp'овая функция <code>apply</code> принимает два аргумента:
      функцию и список аргументов для функции. <code>apply</code>
      возвращает значение выполненной функции с данными
      аргументами.
      Попробуйте сами:
</p>
<blockquote>




<pre class="example">(apply #'cons '(a b))
(apply #'+ '(1 2 3 4))
</pre>


</blockquote>


<dl>
<dt>Именованные параметры </dt><dd>Проблема необязательных
          параметров в том, что если вы определили несколько
          необязательных аргументов, и пользователь хочет указать
          только второй из них, а первых оставить по-умолчанию, ему
          всё равно придётся указать первый аргумент. То есть
          первый фактический аргумент после обязательных
          аргументов, будет связан только с первым необязательным
          аргументом и никаким другим.

<p>
        Именованные параметры являются необязательными, но их
        аргументы могут передаваться в любом порядке, и любой из
        них может быть указан или не указан вне зависимости от других.
</p>
<p>
        Именованные параметры в лямбда-списке следуют за ключевым
          символом <code>&amp;key</code>. Каждый ключевой символ может выглядеть как
</p>
<blockquote>

<p><code>var</code>
 <code>(var default-value)</code>
 или <code>(var default-value supplied-p)</code>
</p>
</blockquote>


<p>
        Именованный параметр <code>var</code> используется в теле функции как
          обычно, но вот при вызове функции, именованный аргумент
          задаётся с помощью ключевого символа с тем же именем, что
          и параметр, то есть <code>:var</code>.
</p>
<p>
        Упражнение:
</p>
<ol>
<li>Попробуйте сами:

<blockquote>




<pre class="example">(defun testKey (a &amp;key oneKey (twoKey 99 2Suppliedp))
  (list a oneKey twoKey
    (if 2Suppliedp '(supplied) '(default))))
(testKey 2)
(testKey 2 :oneKey 5)
(testKey 2 :twoKey 5)
(testKey 2 :twoKey 10 :oneKey 5)
</pre>


</blockquote>


</li>
<li>Заметьте, что <code>member</code> имеет два обязательных параметра
           и три именованных.
           Попробуйте сами:

<blockquote>




<pre class="example">(member '(a b) '((a c) (a b) (c a)))
(member '(a b) '((a c) (a b) (c a)) :test #'equal)
(member 'a '((a c) (a b) (c a)))
(member 'a '((a c) (a b) (c a)) :key #'second)
(member 'a '((a c) (a b) (c a)) :key #'second :test-not #'eql)
</pre>


</blockquote>


</li>
<li>Заметьте, что <code>cl:union</code> также принимает три именованных
           параметра. Измените лямбда-список вашей функции <code>union</code>
           так, чтобы она также принимала эти три параметра, и
           передайте эти аргументы в вызов <code>cl:union</code>.

<p>
           Бонус: Функция <code>identity</code> возвращает значение аргумента.
</p>
</li>
</ol>

</dd>
<dt>Вспомогательные параметры </dt><dd>Вспомогательные параметры в лямбда-списке
          следуют за ключевым символом <code>&amp;aux</code>, и представляют
          списком локальных переменных с их значениями. Определение 

<blockquote>




<pre class="example">(defun (var1 ... varn &amp;aux avar1 ... avarm)
  body)
</pre>


</blockquote>



<p>         
        полностью эквивалентно выражению
</p>
<blockquote>




<pre class="example">(defun (var1 ... varn)
  (let* (avar1 ... avarm)
    body))
</pre>


</blockquote>



<p>            
        Упражнение:
</p>
<ol>
<li>Попробуйте сами

<blockquote>




<pre class="example">(defun test (x &amp;aux (x (1+ x)) (y (1+ x)))
  (list x y))
(test 3)
</pre>


</blockquote>


</li>
<li>Перепишите вашу функцию <code>quad-roots</code> с помощью
           вспомогательных параметров.

</li>
</ol>

</dd>
</dl>

</li>
<li>Итерация

<p>
      В Lisp'е есть несколько конструкций для создания
      циклов. Наиболее мощной и сложной является <code>loop</code>.
</p>
<p>
      Простейший вид <code>loop</code> выглядит так:
      <code>(loop expression...)</code>. 
</p>
<blockquote>




<pre class="example">(loop for i from 1 to 10
  do (print (* i i)))
</pre>


</blockquote>


<p>
      "Расширенный loop" содержит последовательность
      <i>подвыражений</i>. Вот простой пример
</p>
<blockquote>




<pre class="example">(loop for i from 1 to 10
  do (print (* i i)))
</pre>


</blockquote>


<p>
      который содержит два подвыражения: (1) <code>for i from 1 to 10</code>
      и (2) <code>do (print (* i i))</code>.
</p>
<p>
      Как вы можете увидеть, loop не выглядит как обычный
      Lisp. В обычном Lisp'е для структурирования программы
      используются списки. Loop синактически является более сложным,
      для структурирования используются "ключевые символы" (ключевые
      не в том смысле, что из пакета <code>keyword</code>). Каждый вид
      подвыражения обозначается отдельным символом, остальные же
      символы используются для внутренней структуры подвыражения.
</p>
<p>
      Существует 7 подвыражений --
      управление итерациями,
      проверка завершения,
      накопление значения,
      безусловное выполнение подвыражения,
      условное выполнение подвыражения,
      первое-последнее подвыражение,
      локальные переменные.
</p>
<ul>
<li>Управление итерациями

<p>
        Управление итерациями включается символом <code>for</code>.
        Оно позволяет задать первоначальное и последнее значение, а также шаг для
        переменной. При достижении конечного значения цикл
        завершается.
        Управление итерациями содержит 7 подвидов. Некоторые из них
        перечисляют элементы структур данных, один подвид перечисляет
        числа, и один служит для обобщённых целей.
</p>
<ol>
<li>Числовые интервалы:
           <code>for var from start {to | upto | below | downto | above} end [by incr]</code>

<blockquote>




<pre class="example">(loop for i from 99 downto 66 by 3
  do (print i))
</pre>


</blockquote>



</li>
<li>Элементы списка:
           <code>for var in list [by step-fun]</code>

<blockquote>




<pre class="example">(loop for x in '(a b c d e)
  do (print x))

(loop for x in '(a b c d e) by #'cddr
  do (print x))
</pre>


</blockquote>


<p>
           Интересной особенностью является то, что
           можно использовать <i>деструктуризацию</i>.
</p>
<blockquote>




<pre class="example">;; Не обращайте внимание на =format=
;; Мы поговорим о нём позже

(loop for (l n) in '((a 1) (b 2) (c 3) (d 4) (e 5))
  do (format t "~a is the ~:r letter~%" l n))

(loop for (first . rest) in '((42) (a b) (1 2 3) (fee fie foe fum))
  do (format t "~3a has ~d friend~:*~p~%" first (length rest)))
</pre>


</blockquote>



</li>
<li>Подсписки списка: <code>for var on list [by step-fun]</code>

<blockquote>




<pre class="example">(loop for x on '(a b c d e)
  do (print x))

(loop for x on '(a b c d e) by #'cddr
  do (print x))
</pre>


</blockquote>


<p>
           И опять таки с деструктуризацией:
</p>
<blockquote>




<pre class="example">(loop for (x y) on '(a b c d e f) by #'cddr
  do (print (list x y)))
</pre>


</blockquote>


</li>
<li>Элементы вектора: <code>for var across vector</code>

<blockquote>




<pre class="example">(loop for c across "мама мыла раму"
  do (print (char-upcase c)))
</pre>


</blockquote>


</li>
<li>Элементы хеш-таблиц:
           <code>for var being each {hash-key | hash-value} of            hash-table</code>

</li>
<li>Символы пакета:
           <code>for var being each {present-symbol | symbol | external-symbol} [of package]</code>

<blockquote>




<pre class="example">(loop for x being each present-symbol of *package*
  do (print x))
</pre>


</blockquote>


</li>
<li>Что угодно
           <code>for var = expression [then expression]</code>

<blockquote>




<pre class="example">(loop
  for x from 0 below 10
  for y = (+ (* 3 x x) (* 2 x) 1)
  do (print (list x y)))

(loop
  for l in '(a b c d e)
  for m = 1 then (* 2 m)
  do (format t "битовая маска для ~a ~d~%" l m))

(loop
  for prev = #\d then next
  for next across "avid"
  do (format t "~a стоит перед ~a~%" prev next))
</pre>


</blockquote>


</li>
</ol>

<p>        Подвыражения в управление итерациями обычно выполняются
        последовательно.
        Вычисление шага может выполнятся параллельно, если
        использовать символ <code>and</code>.
</p>
</li>
<li>Накопление значения
        Обычно, <code>loop</code> возвращает =nil. Однако накопление значения
        может изменить это поведение.

<p>
        Подвыражение для накопления значения в список выглядит так:
        <code>{collect | append} expression [into var]</code>.
</p>
<blockquote>




<pre class="example">(defun explode (string)
  (loop for c across string collect c))

(defun flatten (tree)
  (if (listp tree)
    (loop for child in tree append (flatten child))
    (list tree)))

(loop for r on '(a b c d e)
  collect (length r)
  append r)
</pre>


</blockquote>



<p>          
        Подвыражение для накопления численного значения выглядит так:
        <code>{count | sum | minimize | maximize} expression [into var]</code>.
</p>
<blockquote>




<pre class="example">(loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
  for n = (length l)
  count l into count
  sum n into sum
  minimize n into min
  maximize n into max
  do (print (list count sum min max)))

(loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
  for n = (length l)
  maximize n into max
  sum max)

(loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
  count l
  count l
  sum (length l))
</pre>


</blockquote>


</li>
<li>Первые-последние подвыражения

<blockquote>




<pre class="example">(loop
  initially (format t "testing")
  repeat 10 do
  (sleep 0.5)
  (format t ".")
  finally (format t "done~%"))
</pre>


</blockquote>



<p>          
        Подвыражение <code>finally</code> особенно полезно при возврате
        значения, вычисленного в самом цикле.
</p>
<blockquote>




<pre class="example">(loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
  for n = (length l)
  count l into count
  sum n into sum
  minimize n into min
  maximize n into max
  finally (return (values count sum min max)))

;; just to mess with you
(loop repeat 5 collect (copy-list foo) into foo finally (return foo))
</pre>


</blockquote>


<p>
        Упражнение: Перепишите функцию <code>fact</code> с использованием
        <code>loop</code>. Перепишите также функцию <code>fibonacci</code>.
</p>
</li>
<li>Безусловное выполнение подвыражений

<p>
        Вы уже видели два безусловных выполнения подвыражений
</p>
<ul>
<li><code>do expression ...</code>
</li>
<li><code>return expression</code>

</li>
</ul>

<p>        Только в подвыражениях <code>do</code>, <code>initially</code> и <code>finally</code> после
        ключевого слова допускается последовательность выражений для
        выполнения. Обычно они [выражения] выполняются
        последовательно.
</p>
</li>
<li>Условное выполнение подвыражений

<p>
        Форма условного выполнения подвыражений выглядит так
</p>
<blockquote>




<pre class="example">{if | when | unless} test
  selectable-clause {and selectable-clause}*  
[else
  selectable-clause {and selectable-clause}*]
[end]
</pre>


</blockquote>


<p>
        где <i>selectable-clause</i> может быть:
        накоплением значения,
        безусловным выполнение подвыражения
        условным выполнением выражения.
</p>
<blockquote>




<pre class="example">(loop for x in '((1 2 3) 4 (5 6) 7 8)
  if (listp x)
    sum (apply #'* x)
  else
    sum x)
</pre>


</blockquote>



<p>          
        Упражнение: Перепишите функцию <code>get-property</code> с
        использованием <code>loop</code>. Объясните чем новая реализация лучше
        старой, принимая во внимание то, что нечётные элементы
        списка это ключи, а чётные - значения.
</p>
</li>
<li>Проверка завершения

<ul>
<li><code>repeat number</code>
</li>
<li><code>while test</code>
</li>
<li><code>until test</code>
</li>
<li><code>always expression</code>
</li>
<li><code>never expression</code>
</li>
<li><code>thereis expression</code>

<blockquote>




<pre class="example">(defun power (x n)
  (loop repeat n
    for y = x then (* y x)
    finally (return y)))

(defun user-likes-lisp-p ()
  (loop initially (format t "Вы любите Lisp? ")
    for x = (read)
    until (member x '(д н))
    do (format t "Пожалуйста ответьте `д' или `н'. ")
    finally (return (eql x 'д))))

(defun composite-p (n)
  (loop for k from 2 below (sqrt (1+ n))
    thereis (when (zerop (nth-value 1 (floor n k))) k)))

;; just for fun
(defun prime-factorization (n)
  (let ((k (composite-p n)))
    (if k
      (append (prime-factorization k) (prime-factorization (floor n k)))
      (list n))))
</pre>


</blockquote>


<p>
        Упражнение: Создайте функцию <code>(split list splitters)</code>,
        которая возвращает список элементов списка <i>list</i>, которые
        заключены между элементами <i>splitters</i>. Например, 
        <code>(split '(1 2 3 4 5 6 7 8 9) '(3 6)) =&gt; '((1 2) (4 5) (7 8         9))</code>.
        (Подсказка: используйте вложенные циклы.)
</p>
<p>
        Существует ещё два способа остановить цикл. Форма <code>(return         [value])</code> немедленно останавливает цикл и возвращает
        <i>value</i>. Форма <code>(loop-finish)</code> останавливает цикл, вычисляя
        подвыражения <code>finally</code>, и возвращает все накопленные значения.
</p>
<p>
        Циклу можно назначить имя &ndash; <code>(loop named name         clauses...)</code>. Из такого цикла можно выйти с помощью
        <code>(return-from name [value])</code>. (Если уточнить, то loop
        устанавливает неявный block с заданным именем, или с именем
        <code>nil</code>.)
</p>
</li>
<li>Локальные переменные

<blockquote>




<pre class="example">(loop with s = "дэвид пирс"
  for prev = (char s 0) then next
  for next across (subseq s 1)
  do (format t "~a came before ~a~%" prev next))
</pre>


</blockquote>


<p>
        Подвыражения <code>with</code> обычно инициализируются последовательно.
        Для параллельной инициализации необходимо использовать
        <code>and</code>.
</p>
</li>
</ul>

<p>      Автор завершает данный урок дополнительными словами о циклах.
</p>
<ul>
<li>Как мы увидели, завершение цикла может произойти в
        нескольких местах &ndash; в управлении итерациями, в проверке
        завершения, и при использовании <code>return</code> и <code>loop-finish</code>. 
        Цикл завершает при выполнении <i>первого</i> из этих выражений. В
        зависимости от завершения, цикл может вернуть или не вернуть
        значение, и выполнить или не выполнить последние выражения.

</li>
<li>Кроме того <code>loop</code> достаточно гибкий в порядке расположения
        подвыражений. Главное правило в том, что выражения "для
        переменных" должны идти перед выражениями "для выполнения".
        Выражения "для переменных" это управление итерациями и
        локальные переменные. Выражения "для выполнения" это
        выполнение, накопление значения и проверка
        завершения. Первые-последние выражения могут быть в любом
        месте.

</li>
</ul>

</li>
<li>Присваивание

<dl>
<dt>Глобальные переменные </dt><dd>

<blockquote>

<p><code>(defconstant name initial-value [documentation])</code>
  Невозможно изменить значение
</p>
<p>
<code>(defparameter name initial-value [documentation])</code>
</p>
<p>
<code>(defvar name [initial-value [documentation]])</code>
  Невозможно переинициализировать переменную. 
</p>
</blockquote>


<p>
        Стиль именования глобальных переменных <code>*var*</code>
</p>
<p>
        Попробуйте сами:
</p>
<blockquote>




<pre class="example">(defconstant *Lab* 'Baldy\ 19
  "Где мы встречаемся.")
*Lab*
(defconstant *Lab* 'Baldy\ 21
  "Где мы встречаемся.")
*Lab*
(defparameter *Time* "TTh 1:30-2:30"
  "Время встречи")
*Time*
(defparameter *Time* "MTh 10:30-1:30"
  "Время встречи")
*Time*
(defvar *Attendance* 20
  "Количество студентов")
*Attendance*
(defvar *Attendance* 6
  "Количество студентов")
*Attendance*
</pre>


</blockquote>


</dd>
<dt>Присваивание </dt><dd>

<blockquote>

<p><code>(set symbol value)</code>
 Выполняет оба аргумента.
</p>
<p>
<code>(setq {symbol value}*)</code>
 Не выполняет выражение <code>symbol</code>. <b>Старый стиль.</b>
</p>
<p>
<code>(setf {place value}*)</code>
 Использует l-value выражения <code>place</code>. Последовательно.
</p>
<p>
<code>(psetf {place value}*)</code>
 Использует l-value выражения <code>place</code>. Параллельно.
</p>
</blockquote>


<p>
        Попробуйте сами:
</p>
<blockquote>




<pre class="example">(setf *Lab* 'Baldy\ 19)
(setf *Time* "TTh 10:30-1:30"
      *Attendance* 10)
*Time*
*Attendance*

(setf x 3 y 5) ; Не присваивайте Don't assign to new global variables in a function body
x
y
(psetf x y y x)
x
y
</pre>


</blockquote>


</dd>
<dt>Обобщённые переменные (места) </dt><dd>Обобщённая переменная
          может быть символом или же специальной формой, которая
          раскрываясь указывает на некоторую область, где можно
          сохранить объект. Например:

<blockquote>




<pre class="example">(setf x '(a b c d e))
(setf (second x) 2)
x

(setf addresses (make-hash-table))
(setf (gethash 'Stu addresses) 'shapiro@cse.buffalo.edu)
(setf (gethash 'David addresses) 'drpierce@cse.buffalo.edu)
(setf (gethash 'Luddite addresses) nil)
(gethash 'David addresses)
(gethash 'Stu addresses)
(gethash 'Luddite addresses)
(gethash 'Bill addresses)
</pre>


</blockquote>


<p>
          Но будьте осторожны:
</p>
<blockquote>




<pre class="example">(defun goodTimers (folks)
   (append folks '(had a good time)))
(setf list1 (goodTimers '(Trupti Mike and Fran)))
(setf (seventh list1) 'bad)
list1
(goodTimers '(Jon Josephine and Orkan))
</pre>


</blockquote>


</dd>
</dl>

<p>      Некоторые полезные глобальные переменные
</p>
<p>
      <code>*</code>
</p>
<p>
      Последний объект возвращённый в РЕПЛе.
</p>
<p>
      <code>**</code>
</p>
<p>
      Предпоследний объект возвращённый в РЕПЛе.
</p>
<p>
      <code>***</code>
</p>
<p>
      Пред-предпоследний объект возвращённый в РЕПЛе.
</p>
<p>
      <code>*package*</code> 
</p>
<p>
      Текущий пакет.
</p>
<p>
      <code>*print-base*</code>
</p>
<p>
      Основание системы счисления при выводе чисел.
</p>
<p>
      <code>*read-base*</code>
</p>
<p>
      Основание системы счисления при вводе чисел.
</p>
<p>
      Упражнение: Превратите Lisp'овый РЕПЛ в конвертер из
      шестнадцатеричной системы счисления в двоичную. А затем наоборот.
</p>
</li>
<li>Последовательное выполнение

<p>
      Сейчас, когда мы рассмотрели присваивание, мы может
      рассмотреть другую императивную конструкцию --
      последовательное выполнение. Здесь нет ничего нового, потому
      что многие Lisp'овые формы позволяют выполнять
      последовательности выражений в "теле" формы. Например, это формы defun,
      cond и let.
</p>
<p>
      Вспомните, что мы называли последовательность выражений в
      "теле" как неявный progn. Это потому, что неявный progn
      является Lisp'овой формой, для создания <i>явной</i>
      последовательности выражений. Результатом формы progn является
      значение последнего выражения. Значения всех остальных
      выражений игнорируются.
</p>
<p>
      Обычно использовать progn нет необходимости, так как
      большинство конструкций создают неявный progn. Однако
      существует набор интересных вариаций progn, которые иногда
      бывают удобны: prog1 и prog2.
</p>
<blockquote>




<pre class="example">(prog1 1 2 3)
(prog2 1 2 3)
(progn 1 2 3)
</pre>


</blockquote>


</li>
<li>Функции

<p>
      Мы уже знаем кое-что о функциях &ndash; как минимум, об именованных
      функция.
</p>
<ul>
<li>Именованные функции создаются с помощью формы <code>defun</code>.
</li>
<li>Функции вызываются с помощью выполнения списка, в котором в
        первом элементе указано имя функции &ndash; <code>(function-name         argument ...)</code>.
</li>
<li>Форма <code>(function function-name)</code> может использоваться для
        получения объекта функции, имея только имя. Выражение
        <code>#'function-name</code> является аббревиатурой для <code>(function         function-name)</code>.

</li>
</ul>

<p>      Что в Lisp'е мы можем сделать с объектами функции?
</p>
<ul>
<li>Функции могут быть присвоены переменными, переданы как
        аргументы, и сохранены в структурах данных, просто как
        любые другие Lisp'овые объекты.
        Функции с такими свойствами, часто называются "функции
        высшего порядка".
</li>
<li>Функции могут применяться к аргументам argument/<sub>1</sub> &hellip;
        /argument/<sub>n</sub> с помощью формы 
        <code>(funcall function argument1 ... argumentn)</code>.
</li>
<li>Функции также могут применяться к аргументам с помощью
        формы <code>(apply function argument1 ... argumentm-1         argumentsm...n)</code>, где <i>arguments/<sub>m&hellip;n</sub> является списком         аргументов от /m</i> до <i>n</i>.

</li>
</ul>

<p>      Некоторые примеры, которые мы уже видели:
</p>
<blockquote>




<pre class="example">(member '(a c) '((a b) (a c) (b c)) :test #'equal)

(loop for x in '(a b c d e) by #'cddr do (print x))
</pre>


</blockquote>


<p>
      Парочка новых:
</p>
<blockquote>




<pre class="example">(funcall #'cons nil nil)

(setf some-functions (list #'third #'first #'second))

(funcall (first some-functions) '(a b c))

(defun multicall (list-of-functions &amp;rest arguments)
  "Returns a list of results obtained by calling each function
in LIST-OF-FUNCTIONS on the ARGUMENTS."
  (loop for f in list-of-functions
    collect (apply f arguments)))

(multicall (list #'third #'second #'first) '(a b c))
</pre>


</blockquote>


<p>
      Упражнение: Определите функцию <code>(tree-member item tree &amp;key       (key #'identity) (test #'eql))</code>, которая возвращает поддерево
      дерева <i>tree</i> с отметками и с корнем <i>item</i>, также как <code>member</code>
      работает для списков. Дерево с отметкой выглядит так <code>(label       . children)</code>, где <i>children</i> является списком дочерних
      элементов. Листья не имеют дочерних элементов. <i>item</i>
      эквивалентно отметке дерева <i>tree</i>, если <code>(test item (key       label))</code> истина. Например:
</p>
<blockquote>




<pre class="example">(tree-member "feline"
  '("animal"
    ("mammal"
     ("feline" ("lion") ("tiger") ("kitty"))
     ("rodent" ("squirrel") ("bunny") ("beaver")))
    ("bird" ("canary") ("pigeon"))
    ("reptile" ("turtle") ("snake")))
  :test #'string=)
==&gt; ("feline" ("lion") ("tiger") ("kitty"))
</pre>


</blockquote>


<p>
      Так как объекты функции могут так гибко использоваться, значит
      возможно, что мы можем создать функцию не задавая для неё
      имени. И ведь да, это делается с помощью формы
      <code>lambda</code>. Лямбда-выражение может быть использовано вместо
      имени функции.
</p>
<blockquote>




<pre class="example">#'(lambda (x) (+ x 1))

((lambda (x) (+ x 1)) 42)

(funcall #'(lambda (x) (+ x 1)) 42)
</pre>


</blockquote>


<p>
      Следует отметить, что 
</p>
<p>
      <code>((lambda lambda-list . body) . arguments)</code> ==
      <code>(funcall #'(lambda lambda-list . body) . arguments)</code>.
</p>
<p>
      А фактически форма <code>function</code> не является необходимой, потому
      что <code>lambda</code> сделана так, что:
</p>
<p>
      <code>(lambda lambda-list . body)</code> ==
      <code>#'(lambda lambda-list . body)</code>.
</p>
<p>
      Лямбда-функции также являются <i>замыканиями</i>, что означает, что
      в них хранится не только их код, но и также лексическое
      окружение.
      Таким образом они запоминают связывания переменных, сделанные
      во время создания этой лямбда-функции.
</p>
<blockquote>




<pre class="example">(defun make-adder (delta)
  (lambda (x) (+ x delta)))

(setf f (make-adder 13))
(funcall f 42)

(funcall (make-adder 11) (funcall (make-adder 22) 33))
</pre>


</blockquote>


<p>
      Упражнение: Определите функцию <code>(compose f g)</code>, которая
      компонует функции <i>f</i> и <i>g</i>.  Допустим, что компоновка <i>f</i> с
      <i>g</i> выглядит как (<i>f • g</i>)(x) = <i>f/(/g/(/x</i>)). Попробуйте 
      <code>(funcall (compose #'char-upcase #'code-char) 100)</code>.
</p>
</li>
<li>Отображение

<p>
      Частенько бывает нужно применить функцию к каждому элементу
      списка и получить результаты каждого вызова. Эта операция
      называется отображение.
      Лямбда-функции в этом смысле очень удобны.
</p>
<blockquote>




<pre class="example">(mapcar #'(lambda (s) (string-capitalize (string s))) '(fee fie foe fum))

(maplist #'reverse '(a b c d e))

(mapcar #'(lambda (s n) (make-list n :initial-element s))
    '(a b c d e) '(5 2 3 7 11))

(mapcan #'(lambda (s n) (make-list n :initial-element s))
    '(a b c d e) '(5 2 3 7 11))

(mapcon #'reverse '(a b c d e))
</pre>


</blockquote>


</li>
<li>Последовательности

<p>
      Последовательности &ndash; это общий суперкласс (родительский класс) для
      списком и векторов (то есть одномерных массивов), или одномерные
      упорядоченные коллекции объектов. Последовательности также
      поддерживают отображения.
</p>
<blockquote>




<pre class="example">(map 'list #'(lambda (c) (position c "0123456789ABCDEF")) "2BAD4BEEF")

(map 'string #'(lambda (a b) (if (char&lt; a b) a b))
     "Дэвид Пирс" "Стью Шапиро")
</pre>


</blockquote>


<p>
      Вот ещё примерчик полезных функций для
      последовательностей. Многие из них принимают функции в
      качестве аргументов.
</p>
<blockquote>




<pre class="example">(count-if #'oddp '(2 11 10 13 4 11 14 14 15) :end 5)

(setf x "Дэвид Пирс")
(sort x #'(lambda (c d)
        (let ((m (char-code c)) (n (char-code d)))
          (if (oddp m)
                (if (oddp n) (&lt; m n) t)
            (if (oddp n) nil (&lt; m n))))))
;; заметьте, что SORT деструктивен
x

(find-if
 #'(lambda (c) (= (* (first c) (first c)) (second c)))
 '((1 3) (3 5) (5 7) (7 9) (2 4) (4 6) (6 8)))

(position-if
 #'(lambda (c) (= (* (first c) (first c)) (second c)))
 '((1 3) (3 5) (5 7) (7 9) (2 4) (4 6) (6 8)))

(reduce #'+ '(1 2 3 4))
(reduce #'list '(a b c d e))
(reduce #'list '(a b c d e) :initial-value 'z)
(reduce #'list '(a b c d e) :from-end t)
(reduce #'append '((a b) (c d) (e f g) (h) (i j k)))
</pre>


</blockquote>


<p>
      Упражнение: Представьте, что вы получили список заголовков для
      столбцов таблицы &ndash; например, <code>("Function " "Arguments "       "Return values " "Author " "Version ")</code>.  Размер столбцов
      вычисляется с помощью длин этих заголовков. Напишите,
      выражение, которые вычисляет количество пробелов (или
      количество места) для вставки в <i>n</i>-нный столбец таблицы.
</p>
</li>
<li>Ввод/Вывод

<p>
      Ввод/вывод (чтение/запись) в Lisp'е основан на потоках. Поток
      это источник или приёмник строковых символов или
      байтов. Например, поток может быть направлен в или из файла,
      строки или терминала. Поток в качестве необязательного
      аргумента принимают функции вывода (записи) (например, <code>format</code>
      и <code>print</code>) и функции ввода (чтения) (например, read). При
      запуске Lisp'а доступны несколько стандартных потоков, включая
      <code>*standard-input*</code>, <code>*standard-output*</code>. Если сессия
      интерактивна, они оба являются синонимами для <code>*terminal-io*</code>.
</p>
<p>
      Основными функциями вывода (записи) являются <code>write-char</code> и
      <code>write-line</code>. Основными функциями ввода (чтения) являются
      <code>read-char</code> и <code>read-line</code>.
</p>
<p>
      Файловые потоки создаются с помощью функции <code>open</code>. Однако,
      удобнее использовать форму <code>with-open-file</code>, которая
      обязательно закроет файл в конце вне зависимости от того,
      возникла ли ошибка или нет в процессе работы с ним.
</p>
<blockquote>




<pre class="example">(with-open-file (output-stream "/tmp/drpierce.txt" ; укажите здесь своё имя
                 :direction :output)
  (write-line "Я люблю Lisp" output-stream))

(with-open-file (input-stream "/tmp/drpierce.txt" :direction :input)
  (read-line input-stream))

(with-open-file (output-stream "/tmp/drpierce.txt" 
                 :direction :output
                 :if-exists :supersede)
  (write-line "1. Lisp" output-stream))

(with-open-file (output-stream "/tmp/drpierce.txt" 
                 :direction :output
                 :if-exists :append)
  (write-line "2. Prolog" output-stream)
  (write-line "3. Java" output-stream)
  (write-line "4. C" output-stream))

;; чтение строк до конца файла
(with-open-file (input-stream "/tmp/drpierce.txt" :direction :input)
  (loop for line = (read-line input-stream nil nil)
    while line
    collect line))
</pre>


</blockquote>


<p>
      Подобным образом, строковый поток обычно управляется с
      помощью <code>with-output-to-string</code> и <code>with-input-from-string</code>.
</p>
<blockquote>




<pre class="example">(with-output-to-string (output-stream)
  (loop for c in '(#\L #\i #\s #\p)
    do (write-char c output-stream)))

(with-input-from-string (input-stream "1 2 3 4 5 6 7 8 9")
  (loop repeat 10 collect (read-char input-stream)))
</pre>


</blockquote>


<p>
      Кроме базовых функций ввода/вывода, вы можете использовать
      высокоуровневый функционал Lisp'овых считывателя и
      печатальщика. Мы рассмотрим их в следующих разделах.
</p>
<p>
      Потоки закрываются с помощью функции <code>close</code>.
      Другие функции для потоков включают
      <code>streamp</code>, <code>open-stream-p</code>, <code>listen</code>, <code>peek-char</code>,
      <code>clear-input</code>, <code>finish-output</code>.
</p>
</li>
<li>Lisp'овый печатальщик

<p>
      Самая главная функция для вывода это <code>write</code>.
      Функции <code>prin1</code>, <code>princ</code>, <code>print</code>, <code>pprint</code> являются обёрткой
      для <code>write</code>. Необязательный аргумент потока в каждой из этих
      функции по умолчанию равен стандартному потоку вывода. Ещё
      один полезный набор функций это <code>write-to-string</code>,
      <code>prin1-to-string</code> и <code>princ-to-string</code>.
</p>
<blockquote>




<pre class="example">(setf z
  '("животные"
    ("млекопитающие"
     ("кошачие" ("лев") ("тигр") ("котенок"))
     ("медведи" ("полярный медведь") ("серый медведь"))
     ("грызуны" ("белка") ("кролик") ("бобёр")))
    ("птицы" ("канарейка") ("голубь"))
    ("рептилии" ("черепаха") ("змея"))))
(prin1 z) ;; эквивалентно (write z :escape t)
(princ z) ;; эквивалентно (write z :escape nil :readably nil)
(write z :escape nil :pretty t :right-margin 40)
(write-to-string z :escape nil :pretty nil)
</pre>


</blockquote>


<p>
      Более сложная и гибкая функция вывода это <code>format</code> &ndash; <code>(format       destination control-string argument...)</code>. Эта функция с помощью
      управляющей строки <i>control-string</i> определяет то, как
      необходимо вывести аргументы <i>argument</i> (если они были) и
      выводит в <i>destination</i>.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">Если <i>destination</i>:</td><td class="left">тогда вывод:</td></tr>
<tr><td class="left"><code>t</code></td><td class="left">в стандартный поток</td></tr>
<tr><td class="left">поток</td><td class="left">в указанный поток</td></tr>
<tr><td class="left"><code>nil</code></td><td class="left">будет возвращён как строка</td></tr>
</tbody>
</table>


<p>       
      Управляющая строка представляет собой простой текст с
      управляющими директивами. Некоторые из них,
      частоиспользуемые, перечислены ниже.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">~W</td><td class="left">вывод как <code>write</code>; любой объект; obey every printer control variable</td></tr>
<tr><td class="left">~S</td><td class="left">вывод как <code>prin1</code>; любой объект; "стандартный" формат</td></tr>
<tr><td class="left">~A</td><td class="left">вывод как <code>princ</code>; любой объект; человекочитаемый формат</td></tr>
<tr><td class="left">~D (или B, O, X)</td><td class="left">десятичный (или бинарный, восьмеричный, шестнадцатиричный) формат числа</td></tr>
<tr><td class="left">~F (или E, G, $)</td><td class="left">фиксированный (экспоненциальный, общий, денежный) формат числа с плавающей точкой</td></tr>
<tr><td class="left"><code>{/control-string/</code>}</td><td class="left">вывод списка; циклично использует управляющую строку <i>control-string</i> для форматирования элементов списка пока он не закончится</td></tr>
<tr><td class="left">~%</td><td class="left">перевод строки</td></tr>
<tr><td class="left">~&amp;</td><td class="left">перевод строки, но только если текущая не пустая</td></tr>
<tr><td class="left">~~</td><td class="left">вывод тильды</td></tr>
<tr><td class="left">~*</td><td class="left">игнорирование текущего элемента</td></tr>
<tr><td class="left">~/newline/</td><td class="left">игнорировать перевод строки и любый последующие пробелы (позволяет разбивать длинные управляющие строки на несколько)</td></tr>
</tbody>
</table>


<p>
      Многие управляющие директивы принимают "аргументы" --
      дополнительные числа или специальные символы между ~ и самой
      последовательностью. Например, аргумент для многих директив
      указывает ширину столбца. Для подробностей смотрите
      документацию для каждой директивы.  В месте "аргумента" для
      директивы, символ <code>v</code> обозначает следующий аргумент функции
      <code>format</code>, тогда как символ <code>#</code> обозначает число предыдущих
      аргументов функции <code>format</code>.
</p>
<blockquote>




<pre class="example">;; форматирование счёта
(loop for (code desc quant price) in
  '((42 "Дом" 1 110e3) (333 "Автомобиль" 2 15000.99) (7 "Конфета" 12 1/4))
  do (format t "~3,'0D ~10A ~3D @ $~10,2,,,'*F~%" code desc quant price))

(defun char-* (character number)
  "Возвращает строку длинной NUMBER заполненную символами CHARACTER."
  (format nil "~v,,,vA" number character ""))
;; но (make-string number :initial-element character) лучше

;; вывод счёта ещё раз в одну строку
(format t "~:{~3,'0D ~10A ~3D @ $~10,2,,,'*F~%~}"
 '((42 "Дом" 1 110e3) (333 "Автомобиль" 2 15000.99) (7 "Конфета" 12 1/4)))

;; список с запятыми-разделителями
(loop for i from 1 to 4 do
  (format t "~{~A~^, ~}~%" (subseq '(1 2 3 4) 0 i)))

;; опять список с запятыми разделителями, но умнее
;; (использует фичи, которые мы не рассматривали
(loop for i from 1 to 4 do
  (format t "~{~A~#[~; и ~:;, ~]~}~%" (subseq '(1 2 3 4) 0 i)))

(loop for i from 1 to 4 do
  (format t "~{~A~#[~;~:;,~]~@{~#[~; and ~A~:; ~A,~]~}~}~%"
      (subseq '(1 2 3 4) 0 i)))

;; опять вывод счёта, но умнее
;; с запятыми в ценах
(loop for (code desc quant price) in
  '((42 "Дом" 1 110e3) (333 "Автомобиль" 2 15000.99) (7 "Конфета" 12 1/4))
  do (format t "~3,'0d ~10a ~3d @ ~{$~7,'*:D~3,2F~}~%"
         code desc quant (multiple-value-list (floor price))))
</pre>


</blockquote>


<p>
      Упражнение: Создайте <code>(print-properties plist &amp;optional       stream)</code> для вывода списка свойств в поток <i>stream</i> как
      показано ниже. Поток <i>stream</i> по-умолчанию должен быть равен
      <code>*standard-output*</code>.
</p>
<blockquote>




<pre class="example">(print-properties '(course CSE-202 semester "Summer 2004"
            room "Baldy 21" days "MR" time (10.30 11.30)))
--&gt;
course=CSE-202
semester="Summer 2004"
room="Baldy 21"
days="MR"
time=(10.3 11.3)
</pre>


</blockquote>


</li>
<li>Считыватель

<p>
      Основной функцией ввода (чтения) является функция <code>read</code>.
      Кроме неё бывает удобна функция <code>read-from-string</code>.
</p>
<blockquote>




<pre class="example">(with-input-from-string (input-stream "(a b c)")
  (read input-stream))

(with-input-from-string (input-stream "5 (a b) 12.3 #\\c \"foo\" t")
  (loop repeat (read input-stream)
    do (describe (read input-stream))))
</pre>


</blockquote>


<p>
      Ниже представлена функция чтения списка свойств в том формате,
      в котором мы сделали вывод в прошлом разделе.
</p>
<blockquote>




<pre class="example">(defun read-properties (&amp;optional (input-stream *standard-input*))
  "Считывает список свойств из потока INPUT-STREAM.
Входящие данные должны содержать пару свойство-значение каждое в отдельной строке
в форме СВОЙСТВО=ЗНАЧЕНИЕ PROPERTY-NAME=VALUE.  СВОЙСТВО PROPERTY-NAME должно быть 
Lisp'овым символ.  ЗНАЧЕНИЕ VALUE может быть любым читабельным объектом."
  (loop for line = (read-line input-stream nil nil)
    while line
    for pos = (position #\= line)
    unless pos do (error "bad property list format ~s" line)
    collect (read-from-string line t nil :end pos)
    collect (read-from-string line t nil :start (1+ pos))))

(setf p1 '(course CSE-202 semester "Summer 2004"
       room "Baldy 21" days "MR" time (10.30 11.30)))
(setf p2 (with-output-to-string (stream)
       (print-properties p1 stream)))
(setf p3 (with-input-from-string (stream p2)
           (read-properties stream)))
(equal p1 p3)
</pre>


</blockquote>


<p>
      На практике, мы можем захотеть больше проверок на ошибки,
      потому что <code>read-properties</code> прекрасно принимает такой ввод:
</p>
<blockquote>




<pre class="example">(with-input-from-string (stream "привет мир = 1 2 3")
  (read-properties stream))
</pre>


</blockquote>


<p>
      Однако, этот весь пример немного выдуманный, тогда как если вы
      хотите сохранить список свойств или ассоциированный список в
      файле (например, конфигурационном файла для вашего
      приложения), вы можете просто написать готовый список в файл
      вместо форматирования его данных. Тогда вы и из файла можете
      просто прочесть список с конфигурацией.
</p>
<p>
      Мы сможем сделать более осмысленное упражнение после того, как
      поговорим о Lisp'овых "объектах" &ndash; то есть, экземплярах
      классов.  Тогда как экземпляры не имеют читабельного (для
      Lisp'а) формата вывода, частая задача состоит в том, чтобы
      вывести экземпляры в читабельном формате, например, в виде
      списка, чтобы была возможность прочесть их обратно. 
      Теперь следующее упражнение более осмысленное, чем пример со
      списком свойств.
</p>
<p>
      Управжнение: Мы решили использовать компактный формат файла
      для больших, разряжённых массивов. Формат такой:
      <code>dimensions default-value index1 value1 index2 value2 ...</code>.
      Например:
</p>
<blockquote>




<pre class="example">(100 100) 0
(30 30) 30
(60 60) 60
</pre>


</blockquote>


<p>
      Напишите функцию <code>(read-sparse-array &amp;optional input-stream)</code>
      для чтения данного формата и создания массива.
</p>
<p>
      Небольшой проект: Напишите форматировщик
      оглавления. Предположим, что ввод это последовательность
      строк, каждая строка начинается с <i>n</i>-ного количество пробелов
      (<i>n</i> ≥ 0), <i>n</i> обозначает уровень данного заголовка. Например,
      вот оглавление для данного руководства для ввода/вывода:
</p>
<blockquote>




<pre class="example">Input/output
 Streams
  File streams
  String streams
 Stream input and output functions
 Other stream functions
The printer
 Print functions
 Format
  Destinations
  Control directives
  Examples
The reader
</pre>


</blockquote>


<blockquote>




<pre class="example">Ввод/вывод
 Потоки
  Файловые потоки
  Строковые потоки
 Функции для ввода/вывода в/из потока
 Прочие функции для потоков
Lisp'овый печатальщик
 Функции вывода
 Format
  Направления
  Управляющие директивы
  Примеры
Считыватель
</pre>


</blockquote>


<p>
      Прочтите оглавление из потока ввода, пронумеруйте его,
      правильно расставьте отступы и напечатайте в поток
      вывода. Ниже представлен один из возможных форматов.
</p>
<blockquote>




<pre class="example">  I. Ввод/вывод
      A. Потоки
          1. Файловые потоки
          2. Строковые потоки
      B. Функции для ввода/вывода в/из потока.
      C. Прочие функции для потоков
 II. Lisp'овый печатальщик
      A. Функции вывода
      B. Format
          1. Результат
          2. Управляющие директивы
          3. Примеры
III. Считыватель
</pre>


</blockquote>


<p>
      Ваш форматтер для оглавления должен использовать список
      (<i>F/<sub>0</sub> /F/<sub>1</sub> &hellip;). Каждый элемент /F<sub>n</sub></i> представляет
      собой список вида (<i>width</i> <i>labeler</i>), где <i>width</i> это ширина
      отметки для названия уровня <i>n</i> и <i>labeler</i> это функция,
      которая принимает число, и возвращает строку для отметки уровня
      <i>n</i>. Например, оглавление выше было отформатированно с помощью
      следующего списка:
</p>
<blockquote>




<pre class="example">(defparameter *outline-format-1*
    (list
     (list 6 #'(lambda (n) (format nil "~@R." n)))
     ...
</pre>


</blockquote>


<p>
      Метки нулевого уровня имеют ширину в шесть символов, и функция
      для отметок возвращает римскую цифру. Автор предлагает вам
      самим додумать, каким должен быть весь список для форматтера.
</p>
<p>
      Сначала, напишите функцию <code>(read-outline &amp;optional       input-stream)</code>, которая читает план с отступами и создаёт
      список со всеми строками и их уровнями.
</p>
<blockquote>




<pre class="example">((0 "Ввод/вывод")
 (1 "Потоки")
 (2 "Файловые потоки")
 (2 "Строковые потоки")
 (1 "Функции для ввода/вывода в/из потока")
 (1 "Прочие функции для потоков")
 (0 "Lisp'овый печатальщик")
 (1 "Функции вывода")
 (1 "Format")
 (2 "Результат")
 (2 "Управляющие директивы")
 (2 "Примеры")
 (0 "Считыватель"))
</pre>


</blockquote>


<p>
      Затем напишите функцию <code>(print-outline outline outline-format       &amp;optional output-stream)</code> для форматирования данного списка в
      соответствие с форматом <i>outline-format</i>.
</p>
</li>
<li>Объектная система Common Lisp'а (CLOS)

<dl>
<dt>Введение</dt><dd>Объектная система Common Lisp'а
                     (*C*ommon *L*isp *O*bject *S*ystem - далее
                     CLOS) позволяет создавать классы (с
                     множественным наследованием) и обобщённые
                     (полиморфные) функции.

<p>
                     Авторы дадут только упрощённое введение в
                     CLOS. Много деталей останется за кадром.
</p>
<p>                       
                     Многие (но не все) стандартные Common Lisp'овые
                     типы также являются классами. Вот они:
                     <img src="classes.gif"  alt="classes.gif" /> (Найдите два класса
                     с несколькими родителями.)
</p>
</dd>
<dt>Обобщённые функции </dt><dd>Обобщённая функция это набор методов
          с одинаковыми именами и "совместимыми" лямбда-списками,
          при этом обязательные параметры могут указывать на класс
          для их аргументов.

<p>
          Пример 1: Давайте создадим обобщённую функцию, которая
          будет выводит классы для заданных объектов.
</p>
<blockquote>




<pre class="example">(defmethod id ((x number))
    "Выводит сообщение о том, что это число."
    "Я число.")

(defmethod id ((x sequence))
    "Выводит сообщение о том, что это последовательность."
    "Я последовательность.")
</pre>


</blockquote>


<p>
          Протестируйте <code>id</code> для нескольких чисел и
          последовательностей с разными подтипами.
</p>
<p>            
          Протестируйте <code>id</code> для нескольких объектов, не чисел и
          не последовательностей.
</p>
<p>            
          Применяемый метод выбирается для самого нижнего возможного
          класса.
          Упражнение: добавьте метод <code>id</code> для некоторых подклассов
          числа (number) или последовательности (sequence), и
          протестируйте, что они используются в подходящих случаях.
</p>
<p>
          Когда класс <i>C</i> имеет два родительских класса, и
          существует метод для каждого из родителей, какой же из
          них будет использован? Это определяется с помощью <b>списка           предшествующих классов</b> для <i>C</i>. 
</p>
<p>
          Пример 2: Создадим отношение <code>&lt;</code> между числами и символами,
          таким образом списки содержащие числа и символы будут
          отсортированы лексикографически. Числа должны сортироваться
          с помощью <code>cl:&lt;</code>, символы с помощью <code>string&lt;</code>, и любое
          число должно быть <code>&lt;</code> чем любой символ.
          Решение:
</p>
<blockquote>




<pre class="example">(defpackage :closExercises
  (:shadow cl:&lt;))

(in-package :closExercises)

(defmethod &lt; ((n1 number) (n2 number))
  "Если число n1 меньше чем n2 возвращает t, иначе nil."
  (cl:&lt; n1 n2))

(defmethod &lt; ((s1 symbol) (s2 symbol))
  "Если символ s1 меньше чем s2 возвращает t, иначе nil."
  (string&lt; s1 s2))

(defmethod &lt; ((n number) (s symbol))
  "Возвращает t, так как числа меньше символов."
  t)

(defmethod &lt; ((s symbol) (n number))
  "Возвращает nil, так как символы не меньше чисел."
  nil)

(defmethod &lt; ((list1 list) (list2 list))
  "Если список list1 меньше чем  list2 возвращает t, иначе nil."
  ;; Списки упорядочиваются лексикографически в соответствие с их элементами.
  (cond
   ((endp list1) list2)
   ((endp list2) nil)
   ((&lt; (first list1) (first list2)) t)
   ((&lt; (first list2) (first list1)) nil)
   (t (&lt; (rest list1) (rest list2)))))
</pre>


<p>            
          Упражнение: Проверьте методы.
</p>
</blockquote>


<p>
          Обобщённые функции могут использоваться также как и
          обычные. Например, мы может определить <code>&gt;</code> следующим
          образом:
</p>
<blockquote>




<pre class="example">;;; Сначала скрываем cl:&gt;.
(shadow 'cl:&gt;)

;;; Затем создаём &gt;.
(defun &gt; (x y)
  "Если x больше y возвращает t, иначе nil."
  (&lt; y x))
</pre>


</blockquote>



<p>            
          Заметьте, что <code>&gt;</code> автоматически работает для тех же
          классов, для которых работает <code>&lt;</code>.
</p>
<p>            
          Теперь давайте сделаем <code>&lt;</code> с помощью <code>defgeneric</code> и добавим
          строки и списки. Списки должны ставиться после символов,
          списки должны быть после строк. То есть, любое число <code>&lt;</code>
          любого символа, любой символ <code>&lt;</code> любой строки, и любая
          строка <code>&lt;</code> любого списка, числа должны сравниваться
          с помощью <code>cl:&lt;</code>, символы и строки &ndash; с помощью <code>string&lt;</code> и
          списки так, как показано ниже. (Нам действительно нужно
          писуть 16 различных методов?)
          Решение:
</p>
<blockquote>




<pre class="example">(defpackage :closExercises
  (:shadow cl:&lt; cl:&gt;))

(in-package :closExercises)

(defgeneric &lt; (obj1 obj2)
  (:documentation "Если объект obj1 меньше чем объект obj2 возвращает t, иначе nil.")

  (:method ((n1 number) (n2 number))
       "Если число n1 меньше чем число n2 возвращает t, иначе nil. Использует cl:&lt;."
       (cl:&lt; n1 n2))

  (:method ((s1 symbol) (s2 symbol))
       "Если символ s1 меньше чем символ s2 возвращает t, иначе nil. Использует string&lt;."
       (string&lt; s1 s2))
    
  (:method ((s1 string) (s2 string))
       "Если строка s1 меньше чем строка s2 возвращает t, иначе nil. Использует string&lt;."
       (string&lt; s1 s2))

  (:method ((list1 list) (list2 list))
       "Если список list1 лексикографически меньше чем список list2 возвращает t, иначе nil."
       ;; Списки упорядочиваются лексикографически в соответствие с их элементами
       (cond
        ((endp list1) list2)
        ((endp list2) nil)
        ((&lt; (first list1) (first list2)) t)
        ((&lt; (first list2) (first list1)) nil)
        (t (&lt; (rest list1) (rest list2)))))
    
  (:method ((obj1 t) (obj2 t))
       "Если объект obj1 меньше чем объект obj2 возвращает t, учитывает сравнение разных типов."
       (check-type obj1 (or number symbol string list))
       (check-type obj2 (or number symbol string list))
       (member obj2
           (member obj1 '(number symbol string list) :test #'typep)
           :test #'typep)))

(defun &gt; (x y)
  "Если x больше чем y возвращает t, иначе nil."
  (&lt; y x))
</pre>


<p>
          Новая форма:
          <code>check-type</code>.
</p>
<p>
          Упражнения:
</p>
<ol>
<li>Протестируйте то, что написали.

</li>
<li>Добавьте строковые символы, которые ставятся между
           числами и символами и сравниваются с помощью <code>&lt;</code>.


</blockquote>


</dd>
<dt>Классы </dt><dd>Объекты (экземпляры класса) создаются с помощью 
                   <code>(make-instance class ...)</code>.

<p>                     
                   CLOS классы создаются с помощью <code>defclass</code>.
</p>
<p>                     
                   Класс может иметь три специальные опции, мы будем
                   использовать только одну <code>:documentation</code>.
</p>
<p>
                   Класс также может содержать набор слотов, каждый
                   из которых имеет свойства, которые были заданы в
                   параметрах слота. Вот эти параметры:
</p>
<ul>
<li><code>:documentation</code> Строка документации.

</li>
<li><code>:allocation</code> Значение <code>:instance</code> означает, что этот слот
          локальный для каждого экземпляра, значение <code>:class</code>
          означает, что слот один для всех экземпляров класса.

</li>
<li><code>:initarg</code> Символ, который потом используется в
          <code>make-instance</code> для задания значения для слота.

</li>
<li><code>:initform</code> Форма, которая вычисляется при создании
          экземпляра, и возвращает значения для слота.

</li>
<li><code>:reader</code> Символ, которые задаёт имя метода, который
          возвращает значение слота для заданного экземпляра.

</li>
<li><code>:writer</code> Символ, который задаёт имя для метода, который
          используется для установки значения в слот
          экземпляра. Если <code>setSlot</code> является символом, то
          итоговая форма выглядит так <code>(setSlot value instance)</code>

</li>
<li><code>:accessor</code> Символ, которые задаёт имя для метода,
          который используется и для чтения и для установки
          значения в слот экземпляра.

</li>
<li><code>:type</code> Тип данных разрешённых в слоте.

<p>
          Даже если ни <code>:write</code>, ни <code>:accessor</code> не были указаны
          значение слота можно получить или изменить с
          помощью <code>slot-value</code>. Например:
</p>
<blockquote>




<pre class="example">(setf (slot-value object slot-name) value)
</pre>


</blockquote>


<p>
        Можно использовать 
</p>
<blockquote>




<pre class="example">(defmethod initialize-instance :after ((object class) &amp;rest args)
    ...)
</pre>


</blockquote>



<p>                     
        это позволит инициализировать слоты после того как были
        заданы <code>:initarg</code> и <code>:initform</code>.
</p>
<p>
        В качестве примера, мы создадим классы для
        взвешиваемых твёрдых веществ и класс для
        весов. Они определены в файле solids.cl.
</p>
<p>
        Упражнения:
</p>
<ol>
<li>Скопируйте solids.cl в свой файл и протестируйте его.

</li>
<li>Добавьте слот в класс весов, 

</li>
<li>Добавьте метод <code>(removeObject scale object)</code> для
           убирания объекта с весов. Все слоты должны быть
           правильно настроены, а <code>removeObject</code> должен
           сигнализировать ошибку, если объект для убирания не
           находится на весах.
</li>
</ol>

</dd>
</dl>

</li>
</ol>

</dd>
</dl>


<p>
© 2004 Стюарт Шапиро, Дэвид Пирс. Все права защищены.
</p>

<hr/>

<p>
Стюарт Шапиро &lt;<a href="mailto:shapiro@cse.buffalo.edu?subject=Lisp course">shapiro at cse.buffalo.edu</a>&gt;
</p>
<p>
Дэвид Пирс &lt;drpierce at cse.buffalo.edu&gt;
</p>

</div>

<div id="postamble">
<p class="date">Date: 2012-12-09T17:23+0400</p>
<p class="author">Author: </p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.2 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
