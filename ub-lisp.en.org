[[http://www.buffalo.edu/][/UNIVERSITY AT BUFFALO - STATE UNIVERSITY OF
NEW YORK/]]

*The Department of Computer Science & Engineering
 [[http://www.cse.buffalo.edu/][[[UB%20Lisp_files/cselogo.htm]]]]*

/*[[http://www.cse.buffalo.edu/%7Eshapiro/][STUART C. SHAPIRO]]: Lisp
Short Course*/

#+CAPTION: 

[[UB%20Lisp_files/blbinary.htm]]

* A Short Course in Common Lisp
 Summer, 2004
 [[http://www.cse.buffalo.edu/%7Eshapiro/][Stuart C. Shapiro]] &
[[http://www.cse.buffalo.edu/%7Edrpierce/][David R. Pierce]]

--------------

Copyright © 2004 by Stuart C. Shapiro & David R. Pierce. All rights
reserved.

-  Meeting time and place:  :: MTh 10:30 - 11:30, Baldy 21

-  Syllabus План :: 

   1.  Common Lisp Resources Ресурсы о Common Lisp'е

       -  [[http://filonenko-mikhail.github.com/cltl2-doc/][Язык Common Lisp от Гая Стила (пер. на русский)]]
       -  [[http://lisper.ru/pcl/][Practical Common Lisp Peter Seibel (пер. на русский)]]
       -  [[http://www.franz.com/support/documentation/8.1/doc/][Index
          to all Allegro CL version 8.1 symbols]]
       -  [[http://www.franz.com/support/documentation/8.1/ansicl/ansicl.htm][ANSI Common Lisp]]
       -  The [[http://www.lispworks.com/documentation/HyperSpec/Front/][/Common Lisp HyperSpec/]]
       -  Stuart C. Shapiro,
          [[http://www.cse.buffalo.edu/%7Eshapiro/Commonlisp/][Common Lisp: An Interactive Approach]], W. H. Freeman, New York,
          1992.
       -  On-line [[http://www.cse.buffalo.edu/%7Eshapiro/Courses/CSE202/Notes/][Course Notes]] from CSE202 of Fall 2000 to accompany the book
          [[http://www.cse.buffalo.edu/%7Eshapiro/Commonlisp/][Common Lisp: An Interactive Approach]]. (Note: this course is not
          currently operating)

   2.  Common Lisp Development Environment Common Lisp'овые средства разработки

       -   For file preparation, testing, and debugging:  :: 

          -  =xemacs &=
          -  For sample initialization files see the directory
             =~shapiro/.xemacs/=, and, especially,
             =~shapiro/.xemacs/init-for-ac.el=.

       -  Для редактирования, тестирования и отладки:  ::
          - =emacs &=
          - =xemacs &=
          - TODO ссылка на конфиг

       -  For file preparation: Для редактирования файлов: :: 

          1. Use a file extension of =.cl=
          2. Use Common Lisp mode
          3. See the Common Lisp mode commands by doing =C-h m=

          1. Используйте расширение =.cl=
          2. Используйте режим Common Lisp'а
          3. Учите команды этого режима с помощью =C-h m=

       -  For testing and debugging:  Для тестирования и отладки  :: 

          1. =M-x run-acl=
          2. Answer all questions by entering =RET=
          3. See the Inferior Common Lisp mode commands by doing =C-h m=

          1. =M-x slime=
          2. Учите команды интерактивной Common Lisp'овой среды с помощью =C-h m=

   3.  Lisp Execution Style Лисповый стиль программирования

       -  Expression-oriented: Evaluate a series of expressions.
       -  Optionally take input from a file, then from standard-input.
       -  The Lisp Listener.
       -  The read-eval-print loop.

       -  Ориентирован на выражения: Последовательное вычисление выражений.
       -  Можно считывать выражения из файла, можно их сразу писать в стандартный ввод.
       -  Lisp'овая машина.
       -  Цикл чтение-выполнение-вывод.

   4.  Numbers Числа

       -  A number is an atom that evaluates to itself. Числа являются
          атомами, которые вычисляются сами в себя.
       -  Test read-eval-print loop
           Попробуйте цикл чтение-выполнение-вывод Really: Ну правда,
          всё просто:

          1. Read Чтение
          2. Construct an object Создание объекта
          3. Evaluate the object Выполнение объекта
          4. Choose a printed representation Выбор текстового
             представления объекта
          5. Print Вывод

       -  Two surprises: Два сюрприза:

          1. bignums большие числа (bignums)
          2. ratios дроби (ratios)

   5.  Non-Atomic Expressions Неатомные выражения

       -  Cambridge prefix notation Кембриджская префиксная нотация
       -  Смотрите [[http://filonenko-mikhail.github.com/cltl2-doc/ru/number.html#x80-11700012][главу Числа]]
       -  See the HyperSpec section on
          [[http://www.lispworks.com/reference/HyperSpec/Body/12_aa.htm][Numeric Operations]]

   6.  (X)Emacs' =*scratch*= buffer is in Lisp Interaction mode
       (X)Emacs'овый буфер =*scratch* находится в режиме исполнения Lisp'ового кода=
       Type =C-j= after a Lisp form. Нажмите Ctrl-j после Lisp'овой
       формы.

   7.  Exiting:
        Выход: =(exit)= or =:ex= to the Lisp Listener. (exit) или :ex в
       Лисповом режиме.

   8.  Booleans Логические (булевы) значения

       -  Lisp's False is =nil=, an atom that evaluates to itself.
          Try it. 

       -  Lisp'овая Ложь это =nil= (пустой список) - атом, который
          вычисляется сам в себя.
          Попробуйте сами. 

       -  Lisp's True is =t=, an atom that evaluates to itself, /and
          every other Lisp object except/ =nil=.

       -  Lisp'овая Истина это =t= (символ =t=) - атом, который вычисляется сам в
          себя. /Любой другой Lisp'овый объект кроме =nil=, также является
          истиной/.

       -  [[http://www.lispworks.com/reference/HyperSpec/Body/m_and.htm][=and=]] and [[http://www.lispworks.com/reference/HyperSpec/Body/m_or.htm][=or=]] are Lisp [[http://www.lispworks.com/reference/HyperSpec/Body/03_ababb.htm][macro]]s
          that take an arbitrary number of
          arguments, and do short-circuit evaluation.
           Try them for different numbers of arguments.
           Try them with zero arguments.
           They return =t=, =nil=, or the value of the last expression
          evaluated under their control, /a theme in Lisp/.

       -  [[http://filonenko-mikhail.github.com/cltl2-doc/ru/clmse34.html#dx45-73002][=and=]] и [[http://filonenko-mikhail.github.com/cltl2-doc/ru/clmse34.html#dx45-73003][=or=]] являются Lisp'овыми [[http://filonenko-mikhail.github.com/cltl2-doc/ru/clmse46.html#dx59-96002][макросами]],
          которые принимают любое количество аргументов, и лениво их вычисляют.
          Попробуйте сами указывая разное количество аргументов.
          Попробуйте вызвать их вообще без аргументов.
          Эти макросы возвращают =t=, =nil= или значение последнего вычисленного выражения.
          

       Exercise: Start a file for Lisp source code.
        For now, just put some comments at the top saying what it's for.

       Упражнение: Создайте файл для Lisp'ового кода. Теперь в начале
        просто наберите несколько комментариев для указания
        предназначения файла.

   9.  Comment Characters Комментарии

       #+BEGIN_QUOTE
         | =;=                | Rest of line     | In line after code          |
         | =;;=               | Entire line      | Indent like code            |
         | =;;;=              | Entire line      | Start in column 1           |
         | =#\vert... \vert#= | Comment brackets | Use for commenting-out code |
       #+END_QUOTE

       #+BEGIN_QUOTE
         | =;=                 | В конце строки                        | В строке после кода             |
         | =;;=                | Во всю строку                         | Отступ как у кода               |
         | =;;;=               | Во всю строку                         | В начале строки                 |
         | =#\vert ... \vert#= | Скобки для многострочных комментариев | Для комментирования блоков кода |
       #+END_QUOTE

   10. Defining Functions Создание функций

       -  See the ANSI Common Lisp section on the [[=defun=]] macro

       -  Изучите раздел о макросе [[http://filonenko-mikhail.github.com/cltl2-doc/ru/clmse30.html#dx40-64001][=defun=]]
          
       -  Example

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun average (x y)
                  "Returns the average of the numbers x and y."
                  ;; Doesn't round or truncate integers
                  (/ (+ x y) 2))
            #+END_EXAMPLE
          #+END_QUOTE

       -  Например

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun average (x y)
                  "Возвращает среднее арифметическое для чисел x и y."
                  ;; Не округляет и не сокращает целые числа
                  (/ (+ x y) 2))
            #+END_EXAMPLE
          #+END_QUOTE

       -  Variables have lexical scope.

       -  Переменные имеют лексическое пространство.

       -  Objects, not variables have type.
          Try =(type-of n)= for various numbers, =n=

       -  Объекты, а не переменные, имеют тип.

       -  Load your file:
           =(load "file-name")= to Listener
           or =:ld file-name= to Listener
           or =:cl file-name= to Listener
           or =C-c C-b= in source file buffer
           or =C-u C-c C-b= in source file buffer

          Then try:
           =(average = and then pause and look at the minibuffer
           =(average 5 7)=
           =(average 5 8)=
           =(float (average 5 8))=

       -  Загрузите файл:
           =(load "file-name")= в РЕПЛе
           или =C-c C-l= в буфере с исходным кодом

       -  Exercise: Define =(discrim a b c)= to return the square root
          of =b2 - 4ac=
           =(discrim 2 7 5)= should return =3.0=

       -  Упраженение: Определите =(discrim a b c)=, которая
          возвращает квадратный корень выражения =b2 - 4ac=
           =(discrim 2 7 5)= должна вернуть =3.0=

       -  Surprise: Lisp functions can return multiple values
           Try =(floor 5.25)= and =(round 5.25)=

       -  Сюрприз в том, что Lisp'овые функции могут возвращать
          несколько значений
           Попробуйте =(floor 5.25)= или =(round 5.25)=

       -  Example

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun +- (x d)
                  "Returns x+d and x-d."
                  (values (+ x d)
                      (- x d)))
            #+END_EXAMPLE
          #+END_QUOTE

          Try: =(values)=

       -  Например

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun +- (x d)
                  "Возвращает x+d и x-d."
                  (values (+ x d)
                      (- x d)))
            #+END_EXAMPLE
          #+END_QUOTE

          Попробуйте: =(values)=

       -  Exercise: Using =discrim=, define =(quad-roots a b c)=
          to return the two roots of the quadradic equation

          #+BEGIN_QUOTE
            ax^{2} + bx + c = 0
          #+END_QUOTE

          namely, =(-b + sqrt(b2 - 4ac))/2a= and
          =(-b - sqrt(b2 - 4ac))/2a=
           =(quad-roots 2 7 5)= should return =-1.0= and =-2.5=

       -  Упражнение: Использую =discrim=, определите =(quad-roots a b c)=
          для возврата корней квадратного уравнения

          #+BEGIN_QUOTE
            ax^{2} + bx + c = 0
          #+END_QUOTE

          то есть, =(-b + sqrt(b2 - 4ac))/2a= и
          =(-b - sqrt(b2 - 4ac))/2a=
           =(quad-roots 2 7 5)= должна возвращать =-1.0= и =-2.5=

   11. Two-Branched Conditional Условное выполнение (две ветки)

       #+BEGIN_QUOTE
         =(if test-form then-form [else-form])=

         Note: =if= is a
         [[http://www.lispworks.com/reference/HyperSpec/Body/03_ababa.htm][special form]]

         Example:

         #+BEGIN_EXAMPLE
             (defun fact (n)
               "Returns the factorial of n."
               (if (<= n 0)
                   1
                 (* n (fact (1- n)))))
         #+END_EXAMPLE

         Exercise: Define =(fibonacci n)= to return the n^{th} Fibonacci
         number: 1 1 2 3 5 8 13 ...
       #+END_QUOTE

         #+BEGIN_QUOTE
         =(if test-form then-form [else-form])=

         Замечание: =if= является специальной формой

         Например:

         #+BEGIN_EXAMPLE
             (defun fact (n)
               "Возвращает факториал от n"
               (if (<= n 0)
                   1
                 (* n (fact (1- n)))))
         #+END_EXAMPLE

         Упражнение: Определите =(fibonacci n)=, которая возвращает n-ое число Фибоначи:
          1 1 2 3 5 8 13 ...
       #+END_QUOTE

   12. Tracing Трассировка
        =(trace function-name ... function-name)= turns on tracing of
       the named functions.
        =(trace)= returns a list of the functions being traced.
        =(untrace function-name ... function-name)= turns off tracing of
       the named functions.
        =(untrace)= turns off all tracing.

        =(trace function-name ... function-name)= включает трассировку
       указанных функций. 
        =(trace)= возвращает список трассируемых
       функций.
        =(untrace function-name ... function-name)= выключает
       трассировку указанных функций
        =(untrace)= выключает все трассировки.
       
       Typing =C-c t= when your cursor is over a function name, either
       in Common Lisp mode or in Inferior Common Lisp mode, toggles
       tracing of that function.
       
       Когда курсор находится на названии функции нажмите =C-c t=, и
       для этой функции включится трассировка.

       Try tracing =discrim= and =quad-root=.
        Try tracing =fact= and/or =fibonacci=.
        Try these with the functions both interpreted and compiled.

       Включите трассировку для функций =discrim= и =quad-root=.

   13. Characters Строковые символы

       -  [[http://www.lispworks.com/reference/HyperSpec/Body/13_.htm][Characters]],
          like numbers, are "self-evaluating atoms". Their syntax is
          =#\=/<name of character>/. Try these:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                #\a
                #\space
                #\newline
            #+END_EXAMPLE
          #+END_QUOTE

       -  Строковые символы, как и числа, это "атомы, которые
          вычисляются в себя". Их синтаксис =#\=/<имя символа>/. Попробуйте сами:
          
          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                #\a
                #\space
                #\newline
            #+END_EXAMPLE
          #+END_QUOTE
          

       -  Lisp handles Unicode characters and character names.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                #\latin_small_letter_a
                #\latin_small_letter_a_with_acute
                #\latin_small_letter_eth
                #\greek_capital_letter_sigma
            #+END_EXAMPLE
          #+END_QUOTE

          Note that =#\latin_small_letter_a= is another example of Lisp
          choosing a print syntax.

       -  Lisp умеет Unicode, поэтому можно делать так.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                #\cyrillic_small_letter_a
                #\cyrillic_small_letter_je
                #\latin_small_letter_eth
                #\greek_capital_letter_sigma
            #+END_EXAMPLE
          #+END_QUOTE
          

       -  Now try this with each of the characters above:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (format t "~a" #\latin_small_letter_a_with_acute)
            #+END_EXAMPLE
          #+END_QUOTE

          [[http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm#format][=Format=]]
          is the Lisp equivalent of =printf=, only (MUCH!) more
          powerful, of course. We will talk about format in detail
          later, but for now, =format t= prints to standard output, and
          =~a= is the control sequence for printing in "human readable"
          format.

          Lisp can represent Unicode characters, but Emacs will only
          gracefull display the ones in the Latin-1 encoding (á and ð).
          You can try others (e.g., =#\greek_capital_letter_sigma=) but
          Emacs won't handle them as gracefully. However, you can see
          the Unicode using
          [[http://www.lispworks.com/reference/HyperSpec/Body/f_char_c.htm#char-code][=char-code=]]:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (char-code #\greek_capital_letter_sigma)
            #+END_EXAMPLE
          #+END_QUOTE

       -  Теперь выполните следующий код:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (format t "~a" #\latin_small_letter_a_with_acute)
            #+END_EXAMPLE
          #+END_QUOTE

          =Format= это Lisp'овый эквивалент функции =printf=, только,
          конечно, (ГОРАЗДО!) более мощный. Мы поговорим подробнее о
          нём позже, но для начала, =format t= просто выводит
          результат в стандартный вывод, и =~a= указывает, что
          напечатанный объект должен быть человекочитаемым.

          Lisp может выводить Unicode символы, но Emacs'у это сделать
          сложнее, поэтому можно вывести код символа с помощью =char-code=:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (char-code #\greek_capital_letter_sigma)
            #+END_EXAMPLE
          #+END_QUOTE

       -  For character comparison, use =char==, =char<=, =char>=.

       -  Для сравнения строковых символов используйте =char=, =char<=, =char>=.

       -  See
          [[http://www.lispworks.com/reference/HyperSpec/Body/13_aa.htm][§13.1.1]]
          for additional useful functions.

       -  Смотрите § для дополнительных полезных функций. TODO

   14. Strings Строки

       -  [[http://www.lispworks.com/reference/HyperSpec/Body/16_.htm][Strings]]
          are also self-evaluating atoms, denoted by a series of
          characters between double quotes.

       -  Строки также являются атомами, которые вычисляются в себя, и
          указываются как последовательность символов между двойными
          кавычками.

       -  Constructing strings:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                "my string"
                (char "my string" 0)
                (char "my string" 2)
                "string with \" in it"
                (char "string with \" in it" 11) 
                (char "string with \" in it" 12) 
                (char "string with \" in it" 13)
                (format t "~a" "string with \" in it")
                (string #\latin_small_letter_a_with_acute)
                (string-capitalize "david.r.pierce")
                (string-trim "as" "sassafras")
                          
            #+END_EXAMPLE
          #+END_QUOTE

       -  Создание строк:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                "вот строка"
                (char "вот строка" 0)
                (char "вот строка" 2)
                "строка с таким \" знаком"
                (char "строка с таким \" знаком" 11) 
                (char "строка с таким \" знаком" 12) 
                (char "строка с таким \" знаком" 13)
                (format t "~a" "строка с таким \" знаком")
                (string #\latin_small_letter_a_with_acute)
                (string-capitalize "дэвид.р.пирс")
                (string-trim "as" "sassafras")
            
            #+END_EXAMPLE
          #+END_QUOTE


       -  Comparing strings:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (string= "david pierce" "David Pierce")
                (string-equal "david pierce" "David Pierce")
                (string< "David Pierce" "Stu Shapiro")
                (string/= "foobar" "foofoo")
                          
            #+END_EXAMPLE
          #+END_QUOTE

       -  Сравнение строк:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (string= "дэвид пирс" "Дэвид Пирс")
                (string-equal "дэвид пирс" "Дэвид Пирс")
                (string< "Дэвид Пирс" "Стью Шапиро")
                (string/= "foobar" "foofoo")
                          
            #+END_EXAMPLE
          #+END_QUOTE

       -  Strings as sequences:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (length "my string")
                (length "\\")
                (format t "~a" "\\")
                (subseq "my string" 3)
                (subseq "my string" 3 6)
                (position #\space "my string")
                (position #\i "David Pierce")
                (position #\i "David Pierce" :start 5)
                (search "pi" "david pierce and stu shapiro")
                (search "pi" "david pierce and stu shapiro" :start2 10)
                (concatenate 'string "foo" "bar")
                (concatenate 'string
                  "d" (string #\latin_small_letter_a_with_grave)
                  "v" (string #\latin_small_letter_i_with_acute)
                  "d")
            #+END_EXAMPLE
          #+END_QUOTE

          [[http://www.lispworks.com/reference/HyperSpec/Body/17_.htm][Sequences]]
          comprise several types that act as ordered containers of
          elements (including lists and arrays as well as strings). Each
          of these functions accepts sequence arguments. We'll talk
          about sequences more later.

       -  Строки как последовательности:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (length "просто строка")
                (length "\\")
                (format t "~a" "\\")
                (subseq "просто строка" 3)
                (subseq "просто строка" 3 6)
                (position #\space "просто строка")
                (position #\i "Дэвид Пирс")
                (position #\i "Дэвид Пирс" :start 5)
                (search "pi" "дэвид пирс и стью шапиро")
                (search "pi" "дэвид пирс и стью шапиро" :start2 10)
                (concatenate 'string "foo" "bar")
                (concatenate 'string
                  "d" (string #\latin_small_letter_a_with_grave)
                  "v" (string #\latin_small_letter_i_with_acute)
                  "d")
            #+END_EXAMPLE
          #+END_QUOTE

       -  Exercise: Define =(string-1+ s)= to construct a new
          string by adding 1 to the character code of each character in
          its argument. For example, =(string-1+ "a b c") => "b!c!d"=.

       -  Упражнение: Определите =(string-1+ s)=, которая создаёт
          новую строку, прибавляя 1 к каждому коду символа старой
          строки. Например, =(string-1+ "a b c") => "b!c!d"=.

   15. Symbols Символы

       -  A
          [[http://www.lispworks.com/reference/HyperSpec/Body/t_symbol.htm#symbol][symbol]]
          is an atom that might have a value, but might not.

       -  Символ является атомом, который может иметь, а может и не
          иметь значение.
          
       -  [[http://www.lispworks.com/reference/HyperSpec/Body/02_cd.htm][Syntax]]:
          almost any sequence of characters (mixed case) that can't be
          interpreted as a number.
           (Warning: In some older implementations, the Lisp reader
          upper-cases all characters entered unless they're escaped.)

       -  Синтаксис:
          почти любая последовательность строковых символов (в разных
          регистрах), которая не может быть числом.
           (Внимание: в некоторых старых реализациях Lisp'а,
          считыватель возводит в верхний регистр все строковые
          символы, даже если были экранированы.)
          
       -  Escape character: =\=
       -  Escape brackets: =| ... |=
       -  Attributes of a symbol

          1. =symbol-name=
          2. =symbol-value=
          3. =symbol-function=
          4. =symbol-package=
          5. =symbol-plist=

       -  Экранирующий строковый символ: =\=
       -  Экранирующие скобки: =| ... |=
       -  Аттрибуты символа

          1. =symbol-name=
          2. =symbol-value=
          3. =symbol-function=
          4. =symbol-package=
          5. =symbol-plist=

       -  Quote: ='expression= always evaluates to =expression= rather
          than the value of =expression=

       -  Квотировние: ='expression= всегда вычисляется в
          =expression=, а не в значение символа =expression=

       -  Load your source file with the definition of =average=
           Try:

          #+BEGIN_EXAMPLE
              (type-of 'average)
              (symbol-name 'average)
              (type-of (symbol-name 'average))
              (symbol-function 'average)
              #'average
              (type-of #'average)
              (type-of (type-of #'average))
              (function-lambda-expression #'average)
          #+END_EXAMPLE

          Load a compiled version of the file (e.g. with =C-c C-b=)
           Try:

          #+BEGIN_EXAMPLE
              #'average
              (function-lambda-expression #'average)
          #+END_EXAMPLE

       -  Загрузите ваш файл с исходным кодом функции =average=
            Попробуйте следующие формы:

          #+BEGIN_EXAMPLE
              (type-of 'average)
              (symbol-name 'average)
              (type-of (symbol-name 'average))
              (symbol-function 'average)
              #'average
              (type-of #'average)
              (type-of (type-of #'average))
              (function-lambda-expression #'average)
          #+END_EXAMPLE

       -  Put your cursor in your =*common-lisp*= buffer, and type
          =C-x 1= to expand it.
           Move your cursor over the symbol =average= in your
          =*common-lisp*= buffer, and type =C-c .= (Really type the
          dot.)

       -  Поместите ваш курсор в буфер и нажмите =C-x 1= 

       -  Equality function for symbols, and identity in general:
          [[http://www.lispworks.com/reference/HyperSpec/Body/a_eql.htm#eql][eql]]
           Try it.

       -  Функция для проверки равенства символов:
          eql
            Попробуйте сами.

       -  How does the Lisp reader locate the symbol from what you type?

          1. Read the characters you typed, and construct a string (the
             symbol's name).
          2. Look up the atom from it's name in a "catalogue" (probably
             a hash table).
          3. If it's not there, create it, and put it there.

          The process of installing a symbol in a catalogue is called
          /interning/ it,
           and a symbol that's been so installed is called an /interned
          symbol/.

       -  Как Lisp'овый считыватель откуда символ, который вы только
          что напечатали?

          1. Считывает все напечатанные строковые символы,
             конструирует строку (имя символа).
          2. Ищет атом по имени в "каталоге" (возможно в хеш-таблице).
          3. Если его там нет, создаёт его, и туда кладёт.

          Процесс установки символа в каталог называется
          /пакетирование/, символ который был инсталлирован /пакетный
          символ/.

   16. Packages Пакеты

       A
       [[http://www.lispworks.com/reference/HyperSpec/Body/t_pkg.htm#package][package]]
       is a catalogue (map) of symbol name => symbol. I.e., a "name
       space".
        There's always a current package which the Lisp reader uses to
       look up symbol names.
        Try typing =*package*= to the Lisp Listener.

       Пакет является каталогом (отображением) имя символа =>
       символ, другими словами, "пространством имён".
        Всегда имеется текущий пакет, который Lisp'овый считыватель
       использует для поиска имён символов.
        Попробуйте выполнить =*package*= в РЕПЛе.

       Lisp packages have nothing to do with file directories or files,
       though the usual style is to have a file "in" only one package.

       Lisp'овые пакеты никак не связаны с директориями или
       файлами. Обычно каждый файл в свою очередь наполняет явно
       указанный пакет.

       A symbol that's interned in a package may be *internal* or
       *external* in that package, and that package is considered the
       symbol's *home package*.
        Find the home package of a symbol by evaluating
       =(symbol-package symbol)=
        Try =(symbol-package 'average)= and =(symbol-package 'length)=

       Пакетированный символ в пакета может быть *внутренним*
       или *внешним*, и данный пакет для символа рассматривается
       как *домашний пакет*.
        Найти домашний пакет для символа можно формой =(symbol-package
        symbol)=
        Попробуйте =(symbol-package 'average)= и =(symbol-package 'length)=

       Every package has a name, and may have one or more nicknames.
        Try: =(package-name (symbol-package 'average))=
        and =(package-nicknames (symbol-package 'average))=

       У каждого пакета есть имя, и также может быть один или
       несколько псевдонимов.
        Попробуйте: =(package-name (symbol-package 'average))=
       и =(package-nicknames (symbol-package 'average))=

       Mappings between packages and their (nick)names:

       #+BEGIN_QUOTE
         =(find-package package-name-or-symbol)=
          =(package-name package)=
          =(package-nicknames package)=
       #+END_QUOTE

       Связь между пакетами и их псевдонимами:

       #+BEGIN_QUOTE
         =(find-package package-name-or-symbol)=
          =(package-name package)=
          =(package-nicknames package)=
       #+END_QUOTE

       Evaluate =(describe 'average)= You should be able to understand
       all or most of what's printed.

       Выполните =(describe 'average)= Вы уже можете понять всё, что
       было получено этой формой.

       Evaluate =(describe 'length)= Notice how many packages there
       are.

       Выполните =(describe 'length)= Обратите внимание сколько было
       получено пакетов.

       Put your cursor on a symbol in either the Lisp listener, or in a
       file of Lisp source code, and type =C-c d=, then =RET= in the
       minibuffer.

       Поместите курсор над символом или в РЕПЛе или в файле с
       Lisp'овым кодом, и нажмите =C-c С-d С-d=, затем =RET= в минибуфере.

       Try =(documentation 'average 'function)=

       Попробуйте =(documentation 'average 'function)=

       Symbol Completion: =C-c TAB=

       Автодополнение символов: =M-TAB=

       You can make a symbol external in its home package by =export=ing
       it.
        Try =(export 'average)=
        Describe =average= again.

       Вы можете сделать символ внешним для домашнего пакета с
       помощью формы =export=.
        Попробуйте =(export 'average)=
        А теперь опять =(describe 'average)=

       You can change packages in the Lisp Listener by entering
       =:pa name-or-symbol=
        Try =:pa lisp= Note the prompt.

       Вы можете изменить пакет с помощью формы =in-package=.
        Попробуйте =(in-package :common-lisp)=

       You can refer to a symbol whose home package is =p= from some
       other package whether or not it is external in =p=.
        To refer to an external symbol =s= in package =p= type =p:s=
        To refer to an internal symbol =s= in package =p= type =p::s=

       Вы можете сослаться на символ с домашним пакетом =p= из
       какого-либо другого пакета, вне зависимости от того является
       ли символ внешним.
        Для ссылки на внешний символ =s= из пакета =p= наберите =p:s=
        Для ссылки на внутренний символ =s= из пакета =p= наберите =p::s=

       Try:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             'cl-user::discrim
             'cl-user::average
             'cl-user:average
             'cl-user::length
             'discrim
         #+END_EXAMPLE
       #+END_QUOTE

       Попробуйте сами:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             'cl-user::discrim
             'cl-user::average
             'cl-user:average
             'cl-user::length
             'discrim
         #+END_EXAMPLE
       #+END_QUOTE

       Notice the printed representation Lisp chooses for these symbols.
        Notice that the last entry caused Lisp to create a symbol named
       ="discrim"= in the =common-lisp= package.
       
       Обратите внимание на печатное представление, которое Lisp
       выбирает для этих символов.
       Обратите внимание, что последняя строка указывает Lisp'у
       создать символ с именем ="discrim"= в пакете =common-lisp=.

       Enter =:pa user= to return to the =common-lisp-user= package.

       Для перехода обратно в пакет common-lisp-user наберите:
       =(in-package :common-lisp-user)=

       Try:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             'cl-user::discrim
             'cl::discrim
             (symbol-name 'discrim)
             (symbol-name 'cl::discrim)
             (string= (symbol-name 'discrim) (symbol-name 'cl::discrim))
             (eql 'discrim 'cl::discrim)
         #+END_EXAMPLE
       #+END_QUOTE

       Попробуйте сами

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             'cl-user::discrim
             'cl::discrim
             (symbol-name 'discrim)
             (symbol-name 'cl::discrim)
             (string= (symbol-name 'discrim) (symbol-name 'cl::discrim))
             (eql 'discrim 'cl::discrim)
         #+END_EXAMPLE
       #+END_QUOTE

       It should not be confusing that =discrim= and =cl::discrim= are
       two /different/ symbols that have the same name.

       Не смущайтесь того, что =discrim= и =cl::discrim= это /разные/
       символы, просто у них одинаковое имя.

       *Two Special Packages* *Два специальных пакета*

       1. The Keyword Package

          Every symbol in the keyword package is external and evaluates
          to itself.
           It is entered with an empty package name and a single =:=
           Try =(describe :foo)=

       1. Пакет ключевых символов
          
          Каждый символ в этом пакете является внешним и вычисляется
          сам в себя.

            Этот символ создаётся с помощью пустого имени пакета и
          одинарного двоеточия =:= Попробуйте =(describe :foo)=

       2. The Non-Package

          If the reader reads =#:s=, it will create an *ininterned*
          symbol named ="s"=, i.e., one that is not interned in any
          package.
           An uninterned symbol can never by found by the Lisp reader,
          and so will never be =eql= to any separately read symbol, even
          one with the same name.

          Try:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (describe '#:foo)
                (eql '#:foo '#:foo)
                (string=  (symbol-name '#:foo) (symbol-name '#:foo))
            #+END_EXAMPLE
          #+END_QUOTE

          Evaluate =(gensym)=. =gensym= creates new uninterned
          symbols.

       2. Непакет

          Если считыватель видит строку вида =#:s=, он
          создаёт *беспакетный* символ с именем ="s"=, то есть символ,
          у которого нет домашнего пакета.
            Безпакетный символ не может быть найден Lisp'овым
          считывателем, и таким образом беспакетные символы никогда
          не равны =eql= друг другу, даже если у них одинаковые имена.

          Попробуйте:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (describe '#:foo)
                (eql '#:foo '#:foo)
                (string=  (symbol-name '#:foo) (symbol-name '#:foo))
            #+END_EXAMPLE
          #+END_QUOTE

          Выполните =(gensym)=. =gensym= создаёт новые беспакетные
          символы.
          

       *Defining Packages*

       *Создание пакетов*

       The simplest way to define a package is by evaluating
       =(defpackage package-name)=, where =package-name=, which is not
       evaluated, is either a string, which will be the package's name,
       or a symbol whose name will be used for the name of the package.
       We recommend using a keyword symbol, such as
       =(defpackage :test)=.

       Самый простой путь создания пакета это форма =(defpackage
       package-name)=, где =package-name=, не вычисляется и должно
       быть строкой или символом (в последнем случае используется имя
       символа). Мы рекомендуем использовать ключевой символ,
       например, =(defpackage :test)=.

       Look at the xemacs buffer in which you've been putting the
       exercises. Notice "=pkg:user=" in the mode line.

       Посмотрите на буфер в Emacs'е, в котором вы выполняли
       упражнения. В модлайне будет указан пакет для данного буфера.

       Enter =(defpackage :test)= as the first form in this file, right
       after your initial comments.

       Введите форму =(defpackage :test)= в самом начале файла, прямо
       сразу за комментариями.

       We want the symbols in this file to be interned into the =test=
       package. So, as the Lisp reader is reading this file, we want to
       change the package to the =test= package right after that package
       has been defined. We'll do this by calling the
       [[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/in-packa.htm][=in-package=]]
       macro, which is what the Listener command =:pa= calls. The
       =in-package= macro takes a string or symbol as its argument, but
       doesn't evaluate it. We recommend using a symbol of the keyword
       package, so put =(in-package :test)= right after the =defpackage=
       form, and save the file.

       Мы хотим, чтобы символы в этом файлы были спакетированы в пакет
       =test=. Это значит надо изменить текущий пакет на =test=, чтобы
       считыватель ориентировался на него. Выполните
       =(in-package :test)= сразу после формы определения
       пакета. Макрос =in-package= принимает строку или символ. Мы
       рекомендуем использовать ключевой символ.

       Notice the package in the mode line hasn't changed (yet). Kill
       the buffer, and reload the file into xemacs. Notice that the
       package in the mode line is correct. This is important, because
       that is the package xemacs will use when you do =C-c C-b= or
       =C-u C-c C-b=.

       Edit your file by changing "=:test=" to "=:exercises=" in both
       places. Save the file. While your cursor is still in the buffer
       containing the file, enter =M-x fi:parse-mode-line-and-package=.
       (Use symbol completion.) Notice that the package in the mode line
       has now been updated properly.

       Xemacs sets the package of a buffer by finding the first
       occurrence of a call to =in-package= in the file. You should not
       have more than one call to =in-package= in any file.

       Exercise: Exit from Lisp, and rerun it. Load your file of
       function definitions. What package is the Listener now in? Test
       some of your functions.

       When Lisp loads a file, it stores the value of =*package*=, and
       restores it after loading the file. That's why you didn't have to
       call =in-package= after loading the file to return to the =user=
       package.

       Когда Lisp загружает файл, он сохраняет, а затем
       восстанавливает =*package*=. Поэтому после загрузки файла вам
       не надо вызывать =in-package= для возврата в ваш пакет.

       Question: Was the Lisp reader "in" the =exercises= package when
       it read every form in your file?

       Вопрос: Находился ли Lisp'овый считыватель в пакете
       =exercises= при чтении форм в вашем файле?

       Make the symbols defining the functions in your =exercises=
       package external by exporting them:
        Change the form

       #+BEGIN_QUOTE
         =(defpackage :exercises)=
       #+END_QUOTE

       to

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defpackage :exercises
                     (:export #:average #:discrim #:fact #:quad-roots #:string-1+))
         #+END_EXAMPLE
       #+END_QUOTE

       Сделайте символы определённые в вашем пакете =exercises=
       внешними:
         Измените форму 

       #+BEGIN_QUOTE
         =(defpackage :exercises)=
       #+END_QUOTE

       на

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defpackage :exercises
                     (:export #:average #:discrim #:fact #:quad-roots #:string-1+))
         #+END_EXAMPLE
       #+END_QUOTE

       Save this version of the file, exit Lisp, run Lisp again, load
       your source file, and try using the functions from the =user=
       package.

       Сохраните эту версию файла, перезагрузите Lisp, загрузите
       файл и попробуйте использовать функции уже из
       =common-lisp-user= пакета.

       *Using Packages*

       *Использование пакетов*

       One package may *use* another package. In that case, in the using
       package every exported symbol of the used package may be referred
       to without a package qualifier.

       Пакет может *использовать* другой пакет. В этом случае, все
       внешние символы используемого пакеты в первом пакете будут
       доступны без указания родительского пакета.

       For example, the =common-lisp-user= package uses the
       =common-lisp= package, which is why you can enter =common-lisp=
       symbols such as =common-lisp:length= without typing the package
       qualifier.
        To see this, evaluate =(package-use-list :user)=.
        The =excl= package contains many symbols used in the Allegro
       Common Lisp implementation that are not in the standard
       =common-lisp= package, such as =excl:exit=.

       Например, пакет =common-lisp-user= использует пакет
       =common-lisp=, поэтому мы можем вызвать функцию length без
       указания пакета =common-lisp=.  
        Посмотреть на это глазами можно с помощью формы =(package-use-list :user)=.

       What packages does the =exercises= package use?
        Every package that's defined uses the =common-lisp= package by
       default. This is important so that pre-defined Lisp functions may
       be accessed easily.

       In the Lisp Listener, in the =user= package, evaluate the form
       =(use-package :exercises)=. Now try using the functions you've
       defined without the package qualifier.

       В РЕПЛе, в пакете =user= выполните форму
       =(use-package :exercises)=. Теперь вызывайте функции без
       указания домашнего пакета.
       
       You may experiment on your own with defining a package and
       explicitly listing other packages for it to use. If you
       explicitly indicate any packages to use, you must explicitly list
       the =common-lisp= package also.

       *Shadowing Symbols*

       *Скрытие символов*

       Exercise: In your exercises file, define the function =last= to
       take a string and return its last character.

       Упражнение: В вашем файле, определите функцию =last=, которая
       принимает строку и возвращает её последний символ.

       You can't, because =last= is the name of a function in the
       =common-lisp= package, and you're not allowed to redefine these
       functions. (Note: functions aren't in packages. Reword that
       statement more carefully.)

       Вы не можете это сделать, потому что =last= это имя функции,
       которая определена в пакете =common-lisp=, вы неможете её
       переопределить.

       There are a lot of symbols in the =common-lisp= package. Must you
       avoid all of them when naming your functions? No!

       В пакете =common-lisp= много символов. Должны ли вы избегать
       коллизий с ними всеми? Нет!

       Change the package in the Lisp Listener to the =exercises=
       package, and shadow =cl:last= by evaluating =(shadow 'last)=, and
       then type your definition of last into the Listener. Test it.

       Измените текущий пакет в РЕПЛе на =exercises=, и скройте
       символ =cl:last= с помощью =(shadow 'last)=, и затем наберите
       ваше определение функции в РЕПЛе. Проверьте результат.

       Add your definition of =last= to your source file, and add the
       form =(:shadow cl:last)= to your =defpackage= form. Also add your
       =last= symbol to those being exported.

       Добавьте ваше определение =last= в ваш файл с исходным кодом,
       и добавьте форму =(:shadow cl:last)= в форму
       =defpackage=. Также добавьте символ =last= в список
       экспортируемых (внешних) символов.

       Exit Lisp. Rerun it. Load your source file. Test your =last=
       function.

       Перезапустите Lisp, загрузите файл. Проверьте функцию =last=.

       Try to have the =user= package use the =exercises= package.
       There's a conflict. Only one symbol with a given name may be
       accessible in any package without qualification. You have to
       choose which one.

       Попробуйте *использовать* пакет =exercises= в пакете
       =user=. Возникнет конфликт. Будет задан вопрос, о том, какой
       из символов =cl:last= или =exercises:last= нужно использовать.

   17. Lists and Conses Списки и Cons-ячейки

       Lists are a fundamental data structure in Lisp, from which the
       language derives its name (LISt Processing).

       Список является фундаментальной структурой данных в Lisp'е, от
       которой и получил своё название язык (LISt Processing).

       A list is an object that holds a sequence of elements, which may
       be (references to) any Lisp objects. The syntax for lists is (/a/
       /b/ /c/ ...). Lists are created by
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_list_.htm][list]].

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             '()
             '(1 2 3)
             (list 1 2 3)
         #+END_EXAMPLE
       #+END_QUOTE

       Список является объектом, который хранит последовательность
       элементов, которые могут быть или ссылаться на Lisp'овые
       объекты. Синтаксис списков такой: (/a/
       /b/ /c/ ...). Списки создаются с помощью формы list.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             '()
             '(1 2 3)
             (list 1 2 3)
         #+END_EXAMPLE
       #+END_QUOTE

       Notice what Lisp prints for ='()= -- =nil=. The symbol =nil= also
       represents the empty list, as well as false.

       Заметьте, что Lisp выводит пустой список ='()= как
       =nil=. Символ =nil= помимо значения Ложь, означает пустой список.

       Exercise: Construct the list containing the two lists =(1 2 3)=
       and =(4 5 6)=.

       Упражнение: Создайте список содержащий два списка =(1 2 3)=
       и =(4 5 6)=.

       Accessing elements:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (first '(1 2 3))
             (second '(1 2 3))
             (third '(1 2 3))
             (nth 5 '(1 2 3 4 5 6 7 8 9 10))
             (rest '(1 2 3))
             (rest (rest '(1 2 3)))
             (nthcdr 0 '(1 2 3 4 5 6 7 8 9 10))
             (nthcdr 5 '(1 2 3 4 5 6 7 8 9 10))
         #+END_EXAMPLE
       #+END_QUOTE

       Доступ к элементам:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (first '(1 2 3))
             (second '(1 2 3))
             (third '(1 2 3))
             (nth 5 '(1 2 3 4 5 6 7 8 9 10))
             (rest '(1 2 3))
             (rest (rest '(1 2 3)))
             (nthcdr 0 '(1 2 3 4 5 6 7 8 9 10))
             (nthcdr 5 '(1 2 3 4 5 6 7 8 9 10))
         #+END_EXAMPLE
       #+END_QUOTE

       [[http://www.lispworks.com/reference/HyperSpec/Body/14_ab.htm][Working with lists]]:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (endp '())
             (endp '(1 2 3))
             (endp nil)
             (endp ())
             (listp '())
             (listp '(1 2 3))
             (eql '(1 2 3) '(1 2 3))
             (equal '(1 2 3) '(1 2 3))
             (length '(1 2 3))
             (append '(1 2 3) '(4 5 6))
             (member 3 '(1 2 3 4 5 6))
             (last '(1 2 3 4 5 6))
             (last '(1 2 3 4 5 6) 3)
             (butlast '(1 2 3 4 5 6))
             (butlast '(1 2 3 4 5 6) 3)
         #+END_EXAMPLE
       #+END_QUOTE

       Работа со списками:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (endp '())
             (endp '(1 2 3))
             (endp nil)
             (endp ())
             (listp '())
             (listp '(1 2 3))
             (eql '(1 2 3) '(1 2 3))
             (equal '(1 2 3) '(1 2 3))
             (length '(1 2 3))
             (append '(1 2 3) '(4 5 6))
             (member 3 '(1 2 3 4 5 6))
             (last '(1 2 3 4 5 6))
             (last '(1 2 3 4 5 6) 3)
             (butlast '(1 2 3 4 5 6))
             (butlast '(1 2 3 4 5 6) 3)
         #+END_EXAMPLE
       #+END_QUOTE

       Lists are also [[sequences]].

       Списки также являются последовательностями.

       Exercise: Write a function =(reverse l)= which returns a list
       containing the elements of list /l/ in reverse order. (Common
       Lisp already includes the =reverse= function, so you must deal
       with the name conflict again.)

       Упражнение: Напишите функцию =(reverse l)=, которая возвращает
       список, содержащий элементы списка /l/ в обратном
       порядке. (Common Lisp уже содержит функцию с таким именем,
       поэтому вам нужно вновь разрешить конфликт имён.)

       The basic building block of a list is called a "cons". A cons is
       an object containing two elements. The elements are called the
       /car/ and the /cdr/ (for historical reasons). The syntax of a
       cons is (/car/ . /cdr/). You can picture a cons such as
       =(1 . 2)= as:

       Базовый строительный объект списка называется
       "cons-ячейка". Cons-ячейка это объект, которые содержит два
       элемента. Элементы называются /car/ и /cdr/ (по историческим
       причинам). Синтаксис cons-ячейки выглядит так: 

       #+BEGIN_QUOTE
         [[UB%20Lisp_files/cons.htm]]
       #+END_QUOTE

       Conses are used to construct (linked) lists in the usual way.

       Cons-ячейки обычно используются для создания (связного) списка.

       #+BEGIN_QUOTE
         [[UB%20Lisp_files/list.htm]]
       #+END_QUOTE

       When we use conses to implement lists, we will often refer to the
       two elements as the /first/ and the /rest/, or the /head/ and the
       /tail/. A list whose final /cdr/ is not the empty list =()= is
       called a "dotted list" (e.g., =(1 2 . 3)=). A "proper list" has
       =()= (i.e., =nil=) as its final /cdr/. The function =cons=
       constructs cons cells. Since lists are implemented using conses,
       it follows that =cons= is also the function to add elements to
       the front of a list.

       Когда мы используем cons-ячейки для построения списков, мы
       будет часто ссылаться на элементы как на /первый/ и
       /оставшийся/, или как на /головной/ и /хвостовой/. Список
       список, которого последний /cdr/ элемент не =nil=, называется
       списком с точкой (например, =(1 2 . 3)=). "Правильный список"
       в последнем /cdr/ содержит =nil=. Функция =cons= создаёт
       cons-ячейку. Так как списки состоят из cons-ячеек функция cons
       также используется для добавления элементов в начало списка.

       Working with conses:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (cons 1 2)
             (cons 1 nil)
             '(1 . nil)
             (cons 1 '(2 3))
             (consp '(1 . 2))
             (car '(1 . 2))
             (cdr '(1 . 2))
             (first '(1 . 2))
             (rest '(1 . 2))
         #+END_EXAMPLE
       #+END_QUOTE

       Работа с cons-ячейками:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (cons 1 2)
             (cons 1 nil)
             '(1 . nil)
             (cons 1 '(2 3))
             (consp '(1 . 2))
             (car '(1 . 2))
             (cdr '(1 . 2))
             (first '(1 . 2))
             (rest '(1 . 2))
         #+END_EXAMPLE
       #+END_QUOTE

       Incidentally, conses can also be used to build binary trees.

       Между прочим, cons-ячейки могут использоваться для создания
       бинарных деревьев.

       #+BEGIN_QUOTE
         [[UB%20Lisp_files/tree.htm]]
       #+END_QUOTE

       Exercise: Construct the binary tree pictured above.

       Упражнение: Создайте бинарное дерево как на картинке.

       Exercise: Define a function =(flatten2 binary-tree)= that returns
       the list of elements in /binary-tree/ in order.

       Упражнение: Определите функцию =(flatten2 binary-tree)=,
       которая возвращает элементы дерева /binary-tree/.

       Moreover, proper lists can be used to build variable-arity trees
       -- for example, ((a (b) c) (d ((e)) () f)).

       Более того, правильные списки могут использоваться для
       создания деревьев с произвольным количеством дочерних
       узлов. Например, ((a (b) c) (d ((e)) () f)).

   18. One-Branch Conditionals Условные переходы (одна ветка)

       [[http://www.lispworks.com/reference/HyperSpec/Body/s_if.htm#if][If]]
       may be used without an /else/ expression. In this case, the
       /else/ expression defaults to =nil=. However, the preferred style
       in such a case is to use
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm#when][when]]
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_when_.htm#unless][unless]].
       In particular, =(when test expression...)= evaluates the
       /test/ and, if its result is true, evaluates the /expression/s in
       order, using the result of the last expression as the final
       result. If the test fails, the result is =nil=. Similarly,
       =(unless test expression...)= evaluates its expressions if
       the result of the test is false.

       If может использоваться без /else/ ветки. В этом случае, /else/
       ветка неявно возвращает =nil=. Однако лучше использовать формы
       when и unless. В частности =(when test expression...)=,
       вычисляет test, и если условие истинно, вычисляет оставшиеся
       выражения, возвращая результат последнего, если условие ложно
       возвращает =nil=. Так же =(unless test expression...)=
       вычисляет выражения, если /test/ ложно.

       Incidentally, many Lisp control structures -- like Lisp programs
       -- allow a sequence of expressions and take their result from the
       last expression. These include defun, when, unless, and cond,
       which we will see next. Control structures that do this are said
       in the language specification to use an "implicit progn". Perhaps
       later we'll mention where this terminology originates.

       Между прочим, многие Lisp'овые формы принимают
       последовательность выражений и возвращают результат последнего
       из них. Сюда входят defun, when, unless и cond, который будут
       рассмотрены далее. Часто говорится, что такие формы содержат
       "неявный progn". 

       One-branch conditionals are particularly useful when the default
       value of a computation is =nil=. For example:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun member (x list)
               "Returns true if x is a member of list."
               (when list
                 (or (eql x (first list)) (member x (rest list)))))
         #+END_EXAMPLE
       #+END_QUOTE

       Условные переходы с одной веткой полезны, в частности,
       тогда. когда по-умолчанию значение для вычисления =nil=. Например:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun member (x list)
               "Возвращает истину, если x содержится в списке list."
               (when list
                 (or (eql x (first list)) (member x (rest list)))))
         #+END_EXAMPLE
       #+END_QUOTE

       Exercise: Write a function =(get-property x list)= which returns
       the element of /list/ immediately following /x/, or /nil/ if /x/
       does not appear in /list/. For example,
       =(get-property 'name '(name david office 125)) => david=.
       (You might take advantage of the fact that Lisp's builtin
       =member= function does not just return =t= when /x/ is in the
       list. You can write this without using =when=, but just for fun,
       use it anyway.) A list of the form used by this function is
       traditionally called a
       [[http://www.lispworks.com/reference/HyperSpec/Body/26_glo_p.htm#property_list][property list]]. Similar builtin functions are [[getf]] and
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_get_pr.htm#get-properties][get-properties]],
       although they take slightly different arrangements of
       arguments.

       Упражнение: Напишите функцию =(get-property x list)=, которая
       возвращает элемент список /list/ сразу за элементом /x/, или
       /nil/, если /x/ в списке /list/ не содержится. Например,
       =(get-property 'name '(name david office 125)) => david=.  (Для
       решения задачи может пригодится функция =member=, которая не
       просто возвращает =t=, когда находит /x/ в списке. Вы можете
       также не использовать функцию =when=, но ради интереса,
       попробуйте и с ней.) Список такого вида, который используется в
       этой функции называется списком свойств. Существуют похожие
       встроенные функции getf и get-properties, они отличаются
       только порядком аргументов.
       

   19. Multi-Branch Conditionals Условные переходы (несколько веток)

       The form of the multi-branch conditional is:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (cond
              (expression11 expression12 ...)
              (expression21 expression22 ...)
              ...
              (expressionn1 expressionn2 ...))
         #+END_EXAMPLE
       #+END_QUOTE

       Форма многоветочного условного перехода выглядит так:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (cond
              (expression11 expression12 ...)
              (expression21 expression22 ...)
              ...
              (expressionn1 expressionn2 ...))
         #+END_EXAMPLE
       #+END_QUOTE

       The =expressioni1= are evaluated starting at /i = 1/ until one of
       them evaluates to any non-=null= value. If so, the rest of the
       expressions in that group (if any) are evaluated, and the value
       of the last one evaluated becomes the value of the =cond=. If all
       of the =expressioni1= evaluate to =nil=, then the value of the
       =cond= is =nil=. As is often the case, the value of a Lisp
       expression is the value of the last subexpression evaluated under
       its control.

       Выражение =expressioni1= вычисляется начиная с /i = 1/ пока одно
       из них не возвратит не-=nil= значение. В этом случае
       вычисляется оставшаяся часть группы, и возвращается значение
       последнего выражения. Если все выражения =expressioni1=
       вернули =nil=, тогда значение формы =cond= также =nil=. Часто
       встречается что значение всего выражения это значение
       последнего выполненного подвыражения.

       Most frequently, =cond= is thought of as:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (cond
              (test1 expression1 ...)
              (test2 expression2 ...)
              ...
              (testn expressionn ...))
         #+END_EXAMPLE
       #+END_QUOTE

       Чаще всего, =cond= рассматривается так:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (cond
              (test1 expression1 ...)
              (test2 expression2 ...)
              ...
              (testn expressionn ...))
         #+END_EXAMPLE
       #+END_QUOTE

       The last /test/ may be =t=, when it is to be considered the
       default clause.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun elt (list index)
               "Returns the index'th element of list, or nil if there isn't one."
               (cond
                ((endp list)
                 nil)
                ((zerop index)
                 (first list))
                (t
                 (elt (rest list) (1- index)))))
         #+END_EXAMPLE
       #+END_QUOTE

       Последнее выражение /test/ может быть =t=, тогда последняя
       ветка является веткой по-умолчанию.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun elt (list index)
               "Returns the index'th element of list, or nil if there isn't one."
               (cond
                ((endp list)
                 nil)
                ((zerop index)
                 (first list))
                (t
                 (elt (rest list) (1- index)))))
         #+END_EXAMPLE
       #+END_QUOTE

       Exercise: Define =(flatten tree)= to take an argument list
       representing a variable-arity tree, and return a list of all the
       atoms which appear in it. For example
       =(flatten '((a (b) c) () (((d e))))) => (a b c d e)=.

       Упражнение: Создайте функцию =(flatten tree)=, которая
       принимает список, который представляет дерево, с произвольным
       количеством веток, и возвращает список, в котором перечислены
       все элементы дерева. Например:
       =(flatten '((a (b) c) () (((d e))))) => (a b c d e)=.

       Another convenient use of the multi-branch conditional is
       encapsulated in the
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_case_.htm#case][case]]
       form. Case implements branching on the value of an expression
       indexed by literal constants (similar to "switch" in other
       languages). For example, suppose we ask someone to guess a
       number:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (case (read)
               (2 "sorry, too low")
               (3 "right on!")
               (4 "sorry, too high")
               (t "way off?!"))
         #+END_EXAMPLE
       #+END_QUOTE

       Другим видом многоветочных условных выражений является форма
       case.
       Case выбирает ветку для исполнения в зависимости от значения
       заданного выражения (в других языках это называется "switch").
       Например, представим, что попросили пользователя загадать число:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (case (read)
               (2 "прости друг, слишком мало")
               (3 "в яблочко!!")
               (4 "прости, слишком много")
               (t "сдался?!"))
         #+END_EXAMPLE
       #+END_QUOTE

       A =case= form is more or less equivalent to a =cond= form as
       follows:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (case expression
               (literal1 result1)
               (literal2 result2)
               ...
               (literaln resultn))
         #+END_EXAMPLE

         ≡

         #+BEGIN_EXAMPLE
             (cond
               ((eql 'literal1 expression) result1)
               ((eql 'literal2 expression) result2)
               ...
               ((eql 'literaln expression) resultn))
         #+END_EXAMPLE
       #+END_QUOTE

       Форму case можно примерно представить в виде формы =cond=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (case expression
               (literal1 result1)
               (literal2 result2)
               ...
               (literaln resultn))
         #+END_EXAMPLE

         ≡

         #+BEGIN_EXAMPLE
             (cond
               ((eql 'literal1 expression) result1)
               ((eql 'literal2 expression) result2)
               ...
               ((eql 'literaln expression) resultn))
         #+END_EXAMPLE
       #+END_QUOTE

       except that /expression/ is only evaluated once. As with =cond=,
       the last clause may be labeled with =t= to indicate that it is
       the default clause. Also notice the quote in the cond, as the
       literals are not evaluated in a =case= form.

       за исключением того, что /expression/ вычисляется единожды.
       Как и в случае =cond=, последнее подвыражение может быть
       обозначено символом =t=, что сделает его, выражением
       по-умолчанию. Также заметьте, что в =case= форме ключ
       выражения не вычисляется, а следовательно его не нужно
       кавычить (квотировать, экранировать).

       Unlike, C's =switch= statement, Lisp's =case= can handle multiple
       cases giving the same answer without the need for a =break=. For
       example,

       #+BEGIN_EXAMPLE
           (case (read)
             ((#\a #\e #\i #\o #\u) 'vowel)
             (#\y 'sometimes\ vowel)
             (t 'consonent))
       #+END_EXAMPLE

       В отличие от сишного выражения =switch=, Lisp'овая =case=
       может иметь несколько ключей для одной ветки, без
       использования функционала =break=. Например,

       #+BEGIN_EXAMPLE
           (case (read)
             ((#\a #\e #\i #\o #\u) 'vowel)
             (#\y 'sometimes\ vowel)
             (t 'consonent))
       #+END_EXAMPLE

   20. Local Variables Локальные переменные

       Remember the =quad-roots= function from a few weeks ago?

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun quad-roots (a b c)
               "Returns the two roots of the equation ax^2 + bx + c."
               (values (/ (+ (- b) (discrim a b c)) (* 2 a))
                   (/ (- (- b) (discrim a b c)) (* 2 a))))
         #+END_EXAMPLE
       #+END_QUOTE

       Помните функцию =quad-roots=?

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun quad-roots (a b c)
               "Возвращает корни квадратного уравнения ax^2 + bx + c."
               (values (/ (+ (- b) (discrim a b c)) (* 2 a))
                   (/ (- (- b) (discrim a b c)) (* 2 a))))
         #+END_EXAMPLE
       #+END_QUOTE

       It would be preferable to avoid recalculating all the
       subexpressions of this formula for the two returned values. Local
       variables are introduced by
       [[http://www.lispworks.com/reference/HyperSpec/Body/s_let_l.htm#let][let]].

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun quad-roots (a b c)
               "Returns the two roots of the equation ax^2 + bx + c."
               (let ((-b (- b))
                     (d  (discrim a b c))
                     (2a (* 2 a)))
                 (values (/ (+ -b d) 2a) (/ (- -b d) 2a))))
         #+END_EXAMPLE
       #+END_QUOTE

       Лучше было бы сэкономить время вычисления и сохранять
       промежуточные результаты в локальных переменных. Локальные
       переменные создаются с помощью формы =let=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun quad-roots (a b c)
               "Возвращает корни квадратного уравнения ax^2 + bx + c."
               (let ((-b (- b))
                     (d  (discrim a b c))
                     (2a (* 2 a)))
                 (values (/ (+ -b d) 2a) (/ (- -b d) 2a))))
         #+END_EXAMPLE
       #+END_QUOTE

       The general form of a let expression is:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((v1 e1)
                   (v2 e2)
                   ...
                   (vn en))
               expression
               ...)
         #+END_EXAMPLE
       #+END_QUOTE

       Основной вид формы =let=:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((v1 e1)
                   (v2 e2)
                   ...
                   (vn en))
               expression
               ...)
         #+END_EXAMPLE
       #+END_QUOTE

       The variables /v/_{1} through /v/_{n} are bound to the results of
       the expressions /e/_{1} through /e/_{n}. These bindings have
       effect throughout the body /expression/s. As usual, the result of
       the let expression is the result of the last body expression.

       Переменные с /v/_{1} по /v/_{n} будут связаны с результатами
       вычислений выражений с /e/_{1} по /e/_{n}. Эти связывания
       актуальны только для тела из выражений /expression/s. Как
       обычно результатом формы =let= является результат последнего
       выражения.

       Let bindings are lexically scoped:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((x 1))
               (list
                 (let ((x 2))
                   x)
                 (let ((x 3))
                   x)))
         #+END_EXAMPLE
       #+END_QUOTE

       Let связывания ограничены лексически:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((x 1))
               (list
                 (let ((x 2))
                   x)
                 (let ((x 3))
                   x)))
         #+END_EXAMPLE
       #+END_QUOTE

       Let bindings are performed in parallel:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((x 3))
               (let ((x (1+ x))
                     (y (1+ x)))
                 (list x y)))
         #+END_EXAMPLE
       #+END_QUOTE

       Let связывания выполняются параллельно:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((x 3))
               (let ((x (1+ x))
                     (y (1+ x)))
                 (list x y)))
         #+END_EXAMPLE
       #+END_QUOTE

       A variant of let called let* performs the bindings
       sequentially.

       =let*= связывания выполняются последовательно.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((x 3))
               (let* ((x (1+ x))
                      (y (1+ x)))
                 (list x y)))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (let ((x 3))
               (let* ((x (1+ x))
                      (y (1+ x)))
                 (list x y)))
         #+END_EXAMPLE
       #+END_QUOTE


   21. [[http://www.franz.com/support/documentation/8.1/ansicl/subsecti/ordinary.htm][Lambda Lists]] The list of formal parameters following the function name
       in a =defun= form is called a /lambda list/. The lambda lists we
       have seen so far contain only required parameters, but there are
       actually a total of five kinds of parameters that might be
       included, in the order listed below.

       Лябмда-списки. /Лямбда-списком/ называется список формальных
       параметров, которые перечислены после имени функции в форме
       =defun=. Лямбда-списки, которые мы видели раньше, содержат
       только обязательные параметры, но фактически они могут
       содержать пять видов параметров, перечисленных ниже.

       -  [[http://www.franz.com/support/documentation/8.1/ansicl/subsubse/specifi2.htm][Required Parameters]]  :: Required parameters are the normal formal
          parameters you are used to. There must be one actual argument
          for each required parameter, and the required parameters are
          bound to the values of the actual arguments in left-to-right
          order.

       -  Обязательные параметры  :: Обязательные параметры это
            обычные формальные параметры, к которым вы привыкли. Для
            каждого обязательного параметра может быть только один
            аргумент, и обязательные параметры связываются со
            значениями аргументов слева направо.
            

       -  [[http://www.franz.com/support/documentation/8.1/ansicl/subsubse/specifi1.htm][Optional Parameters]]  :: Optional parameters follow the lambda list
          keyword =&optional=. Each optional parameter may be

          #+BEGIN_QUOTE
            =var=
             =(var default-value)=
             or =(var default-value supplied-p)=
          #+END_QUOTE

          Необязательные параметры  :: Необязательные параметры
            следуют за ключевым символом =&optional=. Каждый
            необязательный параметр может выглядеть как:

          #+BEGIN_QUOTE
            =var=
             =(var default-value)=
             или =(var default-value supplied-p)=
          #+END_QUOTE

          If there are more actual arguments than required parameters,
          the extras are bound to the optional parameters in
          left-to-right order. If there are extra optional parameters,
          they are bound to the value of =default-value=, if it is
          present, else to =nil=. If =supplied-p= is present and there
          is an actual argument for the optional parameters, it is bound
          to =t=, otherwise it is bound to =nil=.
           Examples:

          1. Notice that the function =last= takes an optional argument.

          2. Try:

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun testOpt (a b &optional c (d 99 dSuppliedp))
                     (list a b c d
                           (if dSuppliedp '(supplied) '(default))))
                   (testOpt 2 3)
                   (testOpt 2 3 4 5)
               #+END_EXAMPLE
             #+END_QUOTE

          Если переданных аргументов больше чем обязательных
          параметров, лишняя часть аргументов будет связана с
          необязательными параметрами слева направо. Если
          необязательные параметры ещё остались, они будут связаны со
          значениями =default-value=, если такие значения указаны,
          или с =nil= в противном случае. Если был указан
          =supplied-p= и при вызове был аргумент для параметра, то
          =supplied-p= будет =t=, иначе =nil=.
            Например:
            
          1. Заметьте, что функция =last= принимает необязательный
             аргумент.

          2. Попробуйте сами:

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun testOpt (a b &optional c (d 99 dSuppliedp))
                     (list a b c d
                           (if dSuppliedp '(supplied) '(default))))
                   (testOpt 2 3)
                   (testOpt 2 3 4 5)
               #+END_EXAMPLE
             #+END_QUOTE

          Exercise: Redefine your =reverse=/=reverse1= pair as the
          single function =reverse=, that takes one required argument
          and one optional argument.

          Упражнение: Переопределите ваши =reverse=/=reverse1= как
          одну функцию =reverse=, которая принимает один
          обязательный аргумент и один необязательный.

       -  [[http://www.franz.com/support/documentation/8.1/ansicl/subsubse/aspecifi.htm][Rest Parameters]]  :: Using required and optional parameters, a
          Lisp function is restricted to a maximum number of actual
          arguments. If the lambda list contains the keyword =&rest=, it
          must be followed by a simple parameter symbol, and that symbol
          is bound to a list of the values of all the actual arguments
          that follow the required arguments.
           Examples:

          Оставшиеся параметры  :: При использовании только обязательных
            и необязательных аргументов Lisp'овая функция ограничивается
            максимальным количеством фактических аргументов. Если
            лямбда-список содержит ключевой символ =&rest=, то после
            него должен только один параметр, который при вызове
            будет содержать список всех значений фактических
            аргументов, которые были переданы после этого параметра.

          1. Notice that the function =-= has one required parameter and
             a rest parameter, so it takes one or more arguments.

          2. Notice that =and= has only a rest parameter, so it takes
             zero or more arguments.

          3. Try

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun testRest (a b &rest c)
                     (list a b c))
                   (testRest 1 2)
                   (testRest 1 2 3 4 5 6)
               #+END_EXAMPLE
             #+END_QUOTE

          1. Заметьте, что функция =-= требует один обязательный
             параметр и оставшиеся параметры, так что функция
             принимает один или более аргументов.

          2. Заметьте, что функция =and= принимает оставшиеся
             параметры, то есть принимает ноль или более аргументов.

          3. Попробуйте сами

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun testRest (a b &rest c)
                     (list a b c))
                   (testRest 1 2)
                   (testRest 1 2 3 4 5 6)
               #+END_EXAMPLE
             #+END_QUOTE

          Exercise: The function [[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/unionnun.htm][=union=]]
          takes two lists and returns a list of all the elements that
          are in either argument list. Try it. Define your own =union=
          function, in your package, that takes zero or more argument
          lists, and, using =cl:union= returns the union of all its
          argument lists.

          Bonus fact: The Lisp function =apply= takes two arguments: a
          function, and a list of arguments for the function. =apply=
          returns the value of applying the function to those arguments.
           Try:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (apply #'cons '(a b))
                (apply #'+ '(1 2 3 4))
            #+END_EXAMPLE
          #+END_QUOTE

          Упражнение: Функция =union= принимает два списка и
          возвращает список, который является объединением первых
          двух. Попробуйте сами. Создайте в своём пакете свою
          функцию =union=, которая принимает ноль и более
          аргументов в виде списков и используя =cl:union= верните
          объединение всех переданных списков.

          Бонус: Lisp'овая функция =apply= принимает два аргумента:
          функцию и список аргументов для функции. =apply=
          возвращает значение выполненной функции с данными
          аргументами.
            Попробуйте сами:
          
          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (apply #'cons '(a b))
                (apply #'+ '(1 2 3 4))
            #+END_EXAMPLE
          #+END_QUOTE


       -  [[http://www.franz.com/support/documentation/8.1/ansicl/subsubse/specifi0.htm][Keyword Parameters]]  :: A problem with optional parameters would
          occur if you defined a function with several optional
          parameters, and the user wanted to call the function with an
          optional argument other than the first. The first actual
          argument after the required arguments would be always be
          assigned to the first optional parameter.

          Именованные параметры  :: Проблема необязательных
            параметров в том, что если вы определили несколько
            необязательных аргументов, и пользователь хочет указать
            только второй из них, а первых оставить по-умолчанию, ему
            всё равно придётся указать первый аргумент. То есть
            первый фактический аргумент после обязательных
            аргументов, будет связан только с первым необязательным
            аргументом и никаким другим.

          Keyword parameters are optional, but their arguments may
          appear in any order, and any one may be supplied or omitted
          independently of the others.

          Именованные параметры являются необязательными, но их
          аргументы могут передаваться в любом порядке, и любой из
          них может быть указан или не указан вне зависимости от других.

          Keyword parameters follow the lambda list keyword =&key=. Each
          keyword parameter may be

          #+BEGIN_QUOTE
            =var=
             =(var default-value)=
             or =(var default-value supplied-p)=
          #+END_QUOTE

          Именованные параметры в лямбда-списке следуют за ключевым
            символом =&key=. Каждый ключевой символ может выглядеть как

          #+BEGIN_QUOTE
            =var=
             =(var default-value)=
             или =(var default-value supplied-p)=
          #+END_QUOTE

          A keyword parameter =var= is used in the body of the function
          as you would expect, but in the function call, a keyword
          argument is specified by preceding it with a symbol in the
          keyword package whose name is the same as the name of the
          =var=, that is, =:var=.

          Exercise:

          Именованный параметр =var= используется в теле функции как
            обычно, но вот при вызове функции, именованный аргумент
            задаётся с помощью ключевого символа с тем же именем, что
            и параметр, то есть =:var=.

          1. Try

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun testKey (a &key oneKey (twoKey 99 2Suppliedp))
                     (list a oneKey twoKey
                       (if 2Suppliedp '(supplied) '(default))))
                   (testKey 2)
                   (testKey 2 :oneKey 5)
                   (testKey 2 :twoKey 5)
                   (testKey 2 :twoKey 10 :oneKey 5)
               #+END_EXAMPLE
             #+END_QUOTE

          2. Notice that =member= has two required parameters and three
             keyword parameters.
              Try

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (member '(a b) '((a c) (a b) (c a)))
                   (member '(a b) '((a c) (a b) (c a)) :test #'equal)
                   (member 'a '((a c) (a b) (c a)))
                   (member 'a '((a c) (a b) (c a)) :key #'second)
                   (member 'a '((a c) (a b) (c a)) :key #'second :test-not #'eql)
               #+END_EXAMPLE
             #+END_QUOTE
             
          3. Notice that
             [[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/unionnun.htm][=cl:union=]]
             also takes three keyword parameters. Modify your
             arbitrary-argument =union= to accept the same three keyword
             parameters, and pass on to =cl:union= those, but only
             those, that are passed to your function.

             Bonus fact: The function
             [[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/identity.htm][=identity=]]
             returns the value of its argument.

          1. Попробуйте сами:

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun testKey (a &key oneKey (twoKey 99 2Suppliedp))
                     (list a oneKey twoKey
                       (if 2Suppliedp '(supplied) '(default))))
                   (testKey 2)
                   (testKey 2 :oneKey 5)
                   (testKey 2 :twoKey 5)
                   (testKey 2 :twoKey 10 :oneKey 5)
               #+END_EXAMPLE
             #+END_QUOTE

          2. Заметьте, что =member= имеет два обязательных параметра
             и три именованных.
             Попробуйте сами:
             
             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (member '(a b) '((a c) (a b) (c a)))
                   (member '(a b) '((a c) (a b) (c a)) :test #'equal)
                   (member 'a '((a c) (a b) (c a)))
                   (member 'a '((a c) (a b) (c a)) :key #'second)
                   (member 'a '((a c) (a b) (c a)) :key #'second :test-not #'eql)
               #+END_EXAMPLE
             #+END_QUOTE

          3. Заметьте, что =cl:union= также принимает три именованных
             параметра. Измените лямбда-список вашей функции =union=
             так, чтобы она также принимала эти три параметра, и
             передайте эти аргументы в вызов =cl:union=.

             Бонус: Функция =identity= возвращает значение аргумента.

       -  [[http://www.franz.com/support/documentation/8.1/ansicl/subsubse/specifie.htm][Aux Parameters]]  :: Aux parameters follow the lambda list keyword
          =&aux=, and are a list of local variables with
          initializations. The definition

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun (var1 ... varn &aux avar1 ... avarm)
                  body)
            #+END_EXAMPLE
          #+END_QUOTE

          is exactly equivalent to

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun (var1 ... varn)
                  (let* (avar1 ... avarm)
                    body))
            #+END_EXAMPLE
          #+END_QUOTE

          Exercise:

          1. Try

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun test (x &aux (x (1+ x)) (y (1+ x)))
                     (list x y))
                   (test 3)
               #+END_EXAMPLE
             #+END_QUOTE

          2. Rewrite your =quad-roots= function to use aux parameters
             instead of let variables.

       -  Вспомогательные параметры  :: Вспомогательные параметры в лямбда-списке
            следуют за ключевым символом =&aux=, и представляют
            списком локальных переменных с их значениями. Определение 

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun (var1 ... varn &aux avar1 ... avarm)
                  body)
            #+END_EXAMPLE
          #+END_QUOTE
         
          полностью эквивалентно выражению

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun (var1 ... varn)
                  (let* (avar1 ... avarm)
                    body))
            #+END_EXAMPLE
          #+END_QUOTE
            
          Упражнение:

          1. Попробуйте сами

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (defun test (x &aux (x (1+ x)) (y (1+ x)))
                     (list x y))
                   (test 3)
               #+END_EXAMPLE
             #+END_QUOTE

          2. Перепишите вашу функцию =quad-roots= с помощью
             вспомогательных параметров.

   22. [[http://www.lispworks.com/reference/HyperSpec/Body/06_.htm][Iteration]] Итерация

       There are a number of iteration constructs in Lisp, but only one
       that you need to know -- the
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_loop.htm#loop][loop]]
       facility. Loop subsumes all the other iteration constructs; and
       it is easier to read and more flexible.

       В Lisp'е есть несколько конструкций для создания
       циклов. Наиболее мощной и сложной является =loop=.

       The simplest kind of loop takes the form:
       =(loop expression...)=. This repeatedly executes the
       /expression/s. The loop is essentially infinite, but you can use
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_return.htm#return][return]]
       to end it.

       Простейший вид loop выглядит так:
       =(loop expression...)=. 

       An "extended loop" consists of a sequence of /loop clauses/. Here
       is a simple example

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (loop for i from 1 to 10
               do (print (* i i)))
         #+END_EXAMPLE
       #+END_QUOTE

       which comprises two clauses: (1) =for i from 1 to 10=; and
       (2) =do (print (* i i))=.

       "Расширенный loop" содержит последовательность
       /подвыражений/. Вот простой пример

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (loop for i from 1 to 10
               do (print (* i i)))
         #+END_EXAMPLE
       #+END_QUOTE

       As you can see, loops don't look like normal Lisp code. Normal
       Lisp code uses list forms to indicate the structure of the
       program. In constrast, since loops are more syntactically
       complex, a number of "loop keywords" are employed to indicate
       their structure. (Loop "keywords" are not really keyword symbols,
       but rather syntactic keywords like the keywords of Java, or the
       keywords of lambda lists -- =&rest=, etc.) Each kind of loop
       clause is introduced by a different keyword. Other keywords are
       used to indicate the internal structure of a compound clause.

       Как вы можете увидеть, loop не выглядит как обычный
       Lisp. В обычном Lisp'е для структурирования программы
       используются списки. Loop синактически является более сложным,
       для структурирования используются "ключевые символы" (ключевые
       не в том смысле, что из пакета =keyword=). Каждый вид
       подвыражения обозначается отдельным символом, остальные же
       символы используются для внутренней структуры подвыражения.

       There are seven kinds of loop clauses --
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_aba.htm][iteration control clauses]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_ad.htm][termination tests]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_ac.htm][value accumulation clauses]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_ae.htm][unconditional execution clauses]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_af.htm][conditional execution clauses]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_agb.htm][initial-final clauses]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/06_abb.htm][local variable clauses]].

       Существует 7 подвыражений --
       * управление итерациями,
       * проверка завершения,
       * накопление значения,
       * безусловное выполнение подвыражения,
       * условное выполнение подвыражения,
       * первое-последнее подвыражение,
       * локальные переменные.
       
       1. [[http://www.lispworks.com/reference/HyperSpec/Body/06_aba.htm][Iteration control clauses]] Управление итерациями

          Iteration control clauses are introduced by the keyword =for=,
          determine how a loop variable is "stepped" between each
          iteration, and arrange for the loop to terminate when finished
          stepping. There are seven kinds of iteration control clauses.
          Some of these clauses iterate over common data structures, one
          iterates numerically, and one is a general-purpose clause.

          Управление итерациями включается символом =for=.
          Оно позволяет задать первоначальное и последнее значение, а также шаг для
          переменной. При достижении конечного значения цикл
          завершается.
          Управление итерациями содержит 7 подвидов. Некоторые из них
          перечисляют элементы структур данных, один подвид перечисляет
          числа, и один служит для обобщённых целей.

          1. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abaa.htm][Numeric ranges]]:
             =for var from start {to | upto | below | downto | above} end [by incr]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for i from 99 downto 66 by 3
                     do (print i))
               #+END_EXAMPLE
             #+END_QUOTE

          1. Числовые интервалы:
             =for var from start {to | upto | below | downto | above} end [by incr]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for i from 99 downto 66 by 3
                     do (print i))
               #+END_EXAMPLE
             #+END_QUOTE
             

          2. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abab.htm][List elements]]: =for var in list [by step-fun]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for x in '(a b c d e)
                     do (print x))

                   (loop for x in '(a b c d e) by #'cddr
                     do (print x))
               #+END_EXAMPLE
             #+END_QUOTE

             An interesting aspect of the loop facility is that it
             allows /destructuring/ bindings.

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   ;; Ignore the format magic used in the following examples for now.
                   ;; We'll talk about format later.

                   (loop for (l n) in '((a 1) (b 2) (c 3) (d 4) (e 5))
                     do (format t "~a is the ~:r letter~%" l n))

                   (loop for (first . rest) in '((42) (a b) (1 2 3) (fee fie foe fum))
                     do (format t "~3a has ~d friend~:*~p~%" first (length rest)))
               #+END_EXAMPLE
             #+END_QUOTE

          2. Элементы списка:
             =for var in list [by step-fun]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for x in '(a b c d e)
                     do (print x))

                   (loop for x in '(a b c d e) by #'cddr
                     do (print x))
               #+END_EXAMPLE
             #+END_QUOTE

             Интересной особенностью является то, что
             можно использовать /деструктуризацию/.

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   ;; Не обращайте внимание на =format=
                   ;; Мы поговорим о нём позже

                   (loop for (l n) in '((a 1) (b 2) (c 3) (d 4) (e 5))
                     do (format t "~a is the ~:r letter~%" l n))

                   (loop for (first . rest) in '((42) (a b) (1 2 3) (fee fie foe fum))
                     do (format t "~3a has ~d friend~:*~p~%" first (length rest)))
               #+END_EXAMPLE
             #+END_QUOTE
             

          3. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abac.htm][List tails]]: =for var on list [by step-fun]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for x on '(a b c d e)
                     do (print x))

                   (loop for x on '(a b c d e) by #'cddr
                     do (print x))
               #+END_EXAMPLE
             #+END_QUOTE

             And with destructuring again:

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for (x y) on '(a b c d e f) by #'cddr
                     do (print (list x y)))
               #+END_EXAMPLE
             #+END_QUOTE

          3. Подсписки списка: =for var on list [by step-fun]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for x on '(a b c d e)
                     do (print x))

                   (loop for x on '(a b c d e) by #'cddr
                     do (print x))
               #+END_EXAMPLE
             #+END_QUOTE

             И опять таки с деструктуризацией:

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for (x y) on '(a b c d e f) by #'cddr
                     do (print (list x y)))
               #+END_EXAMPLE
             #+END_QUOTE

          4. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abae.htm][Vector elements]]: =for var across vector=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for c across "david"
                     do (print (char-upcase c)))
               #+END_EXAMPLE
             #+END_QUOTE

          4. Элементы вектора: =for var across vector=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for c across "мама мыла раму"
                     do (print (char-upcase c)))
               #+END_EXAMPLE
             #+END_QUOTE

          5. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abaf.htm][Hash table elements]]:
             =for var being each {hash-key | hash-value} of
             hash-table=

          5. Элементы хеш-таблиц:
             =for var being each {hash-key | hash-value} of
             hash-table=

          6. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abag.htm][Package symbols]]:
             =for var being each {present-symbol | symbol | external-symbol} [of package]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for x being each present-symbol of *package*
                     do (print x))
               #+END_EXAMPLE
             #+END_QUOTE

          6. Символы пакета:
             =for var being each {present-symbol | symbol | external-symbol} [of package]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop for x being each present-symbol of *package*
                     do (print x))
               #+END_EXAMPLE
             #+END_QUOTE

          7. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abad.htm][Anything]]:
             =for var = expression [then expression]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop
                     for x from 0 below 10
                     for y = (+ (* 3 x x) (* 2 x) 1)
                     do (print (list x y)))

                   (loop
                     for l in '(a b c d e)
                     for m = 1 then (* 2 m)
                     do (format t "the bit mask for ~a is ~d~%" l m))

                   (loop
                     for prev = #\d then next
                     for next across "avid"
                     do (format t "~a came before ~a~%" prev next))
               #+END_EXAMPLE
             #+END_QUOTE

          Iteration control clauses are normally performed sequentially.
          Stepping can be performed in parallel by connecting the
          clauses with =and= rather than =for=.

          7. Что угодно
             =for var = expression [then expression]=

             #+BEGIN_QUOTE
               #+BEGIN_EXAMPLE
                   (loop
                     for x from 0 below 10
                     for y = (+ (* 3 x x) (* 2 x) 1)
                     do (print (list x y)))

                   (loop
                     for l in '(a b c d e)
                     for m = 1 then (* 2 m)
                     do (format t "битовая маска для ~a ~d~%" l m))

                   (loop
                     for prev = #\d then next
                     for next across "avid"
                     do (format t "~a стоит перед ~a~%" prev next))
               #+END_EXAMPLE
             #+END_QUOTE

          Подвыражения в управление итерациями обычно выполняются
          последовательно.
          Вычисление шага может выполнятся параллельно, если
          использовать символ =and=.

       2. [[http://www.lispworks.com/reference/HyperSpec/Body/06_ac.htm][Value accumulation clauses]]

          Normally, =loop= returns =nil=. However, value accumulation
          clauses can determine other values to return.

          List accumulation clauses construct a result list:
          ={collect | append} expression [into var]=.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun explode (string)
                  (loop for c across string collect c))

                (defun flatten (tree)
                  (if (listp tree)
                    (loop for child in tree append (flatten child))
                    (list tree)))

                (loop for r on '(a b c d e)
                  collect (length r)
                  append r)
            #+END_EXAMPLE
          #+END_QUOTE

          Numeric accumulation clauses compute a result value:

          ={count | sum | minimize | maximize} expression [into var]=.
          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  for n = (length l)
                  count l into count
                  sum n into sum
                  minimize n into min
                  maximize n into max
                  do (print (list count sum min max)))

                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  for n = (length l)
                  maximize n into max
                  sum max)

                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  count l
                  count l
                  sum (length l))
            #+END_EXAMPLE
          #+END_QUOTE

       2. Накопление значения
          Обычно, =loop= возвращает =nil. Однако накопление значения
          может изменить это поведение.

          Подвыражение для накопления значения в список выглядит так:
          ={collect | append} expression [into var]=.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun explode (string)
                  (loop for c across string collect c))

                (defun flatten (tree)
                  (if (listp tree)
                    (loop for child in tree append (flatten child))
                    (list tree)))

                (loop for r on '(a b c d e)
                  collect (length r)
                  append r)
            #+END_EXAMPLE
          #+END_QUOTE
          
          Подвыражение для накопления численного значения выглядит так:
          ={count | sum | minimize | maximize} expression [into var]=.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  for n = (length l)
                  count l into count
                  sum n into sum
                  minimize n into min
                  maximize n into max
                  do (print (list count sum min max)))

                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  for n = (length l)
                  maximize n into max
                  sum max)

                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  count l
                  count l
                  sum (length l))
            #+END_EXAMPLE
          #+END_QUOTE

       3. [[http://www.lispworks.com/reference/HyperSpec/Body/06_agb.htm][Initial-final clauses]]

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop
                  initially (format t "testing")
                  repeat 10 do
                  (sleep 0.5)
                  (format t ".")
                  finally (format t "done~%"))
            #+END_EXAMPLE
          #+END_QUOTE

          The =finally= clause is especially useful for returning a
          value computed by the loop.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  for n = (length l)
                  count l into count
                  sum n into sum
                  minimize n into min
                  maximize n into max
                  finally (return (values count sum min max)))

                ;; just to mess with you
                (loop repeat 5 collect (copy-list foo) into foo finally (return foo))
            #+END_EXAMPLE
          #+END_QUOTE

          Exercise: Rewrite the =fact= function using =loop=. Rewrite
          the =fibonacci= function.

       3. Первые-последние подвыражения

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop
                  initially (format t "testing")
                  repeat 10 do
                  (sleep 0.5)
                  (format t ".")
                  finally (format t "done~%"))
            #+END_EXAMPLE
          #+END_QUOTE
          
          Подвыражение =finally= особенно полезно при возврате
          значения, вычисленного в самом цикле.
          
          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop for l in '((1 2 3) () (fee fie foe fum) () (a b c d e))
                  for n = (length l)
                  count l into count
                  sum n into sum
                  minimize n into min
                  maximize n into max
                  finally (return (values count sum min max)))

                ;; just to mess with you
                (loop repeat 5 collect (copy-list foo) into foo finally (return foo))
            #+END_EXAMPLE
          #+END_QUOTE

          Упражнение: Перепишите функцию =fact= с использованием
          =loop=. Перепишите также функцию =fibonacci=.

       4. [[http://www.lispworks.com/reference/HyperSpec/Body/06_ae.htm][Unconditional execution clauses]]

          You've already seen one of the two unconditional execution
          clauses.

          -  =do expression ...=
          -  =return expression=

          The =do=, =initially=, and =finally= clauses are the only
          places in =loop= where a sequence of expressions is allowed
          after a loop keyword. As usual, these are executed
          sequentially.

       4. Безусловное выполнение подвыражений

          Только в подвыражениях =do=, =initially= и =finally= после
          ключевого слова допускается последовательность выражений для
          выполнения. Обычно они [выражения] выполняются
          последовательно.

       5. [[http://www.lispworks.com/reference/HyperSpec/Body/06_af.htm][Conditional execution clauses]]

          The form of a conditional execution clause is

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                {if | when | unless} test
                  selectable-clause {and selectable-clause}*  
                [else
                  selectable-clause {and selectable-clause}*]
                [end]
            #+END_EXAMPLE
          #+END_QUOTE

          where a /selectable-clause/ is a value accumulation clause or
          unconditional or conditional execution clause.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop for x in '((1 2 3) 4 (5 6) 7 8)
                  if (listp x)
                    sum (apply #'* x)
                  else
                    sum x)
            #+END_EXAMPLE
          #+END_QUOTE

          Exercise: Rewrite the =get-property= function using =loop=.
          Explain how your new implementation improves over the old one,
          assuming that even elements of a property list are meant as
          keys and odd elements as values.

       5. Условное выполнение подвыражений

          Форма условного выполнения подвыражений выглядит так

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                {if | when | unless} test
                  selectable-clause {and selectable-clause}*  
                [else
                  selectable-clause {and selectable-clause}*]
                [end]
            #+END_EXAMPLE
          #+END_QUOTE

          где /selectable-clause/ может быть:
          накоплением значения,
          безусловным выполнение подвыражения
          условным выполнением выражения.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop for x in '((1 2 3) 4 (5 6) 7 8)
                  if (listp x)
                    sum (apply #'* x)
                  else
                    sum x)
            #+END_EXAMPLE
          #+END_QUOTE
          
          Упражнение: Перепишите функцию =get-property= с
          использованием =loop=. Объясните чем новая реализация лучше
          старой, принимая во внимание то, что нечётные элементы
          списка это ключи, а чётные - значения.

       6. [[http://www.lispworks.com/reference/HyperSpec/Body/06_ad.htm][Termination tests]]

          Проверка завершения

          -  =repeat number=
          -  =while test=
          -  =until test=
          -  =always expression=
          -  =never expression=
          -  =thereis expression=

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun power (x n)
                  (loop repeat n
                    for y = x then (* y x)
                    finally (return y)))

                (defun user-likes-lisp-p ()
                  (loop initially (format t "Do you like Lisp? ")
                    for x = (read)
                    until (member x '(y n))
                    do (format t "Please type either `y' or `n'. ")
                    finally (return (eql x 'y))))

                (defun composite-p (n)
                  (loop for k from 2 below (sqrt (1+ n))
                    thereis (when (zerop (nth-value 1 (floor n k))) k)))

                ;; just for fun
                (defun prime-factorization (n)
                  (let ((k (composite-p n)))
                    (if k
                      (append (prime-factorization k) (prime-factorization (floor n k)))
                      (list n))))
            #+END_EXAMPLE
          #+END_QUOTE

          Exercise: Define a function =(split list splitters)= that
          returns a list of chunks of the /list/ that occur between
          elements of /splitters/. For example,
          =(split '(1 2 3 4 5 6 7 8 9) '(3 6)) => '((1 2) (4 5) (7 8 9))=.
          (Hint: Use a nested loop.)

          Two other ways of terminating a loop should be mentioned. The
          form =(return [value])= immediately terminates the loop and
          returns the /value/. The form =(loop-finish)= terminates the
          loop, executes the =finally= clauses, and returns any
          accumulated value.

          A loop can be named --
          =(loop named name clauses...)=; and such a loop can
          be terminated using =(return-from name [value])=
          similarly to =return=. (More precisely, a loop establishes an
          implicit
          [[http://www.lispworks.com/reference/HyperSpec/Body/s_block.htm#block][block]]
          of the same name, or =nil=.)

          Упражнение: Создайте функцию =(split list splitters)=,
          которая возвращает список элементов списка /list/, которые
          заключены между элементами /splitters/. Например, 
          =(split '(1 2 3 4 5 6 7 8 9) '(3 6)) => '((1 2) (4 5) (7 8
          9))=.
          (Подсказка: используйте вложенные циклы.)

          Существует ещё два способа остановить цикл. Форма =(return
          [value])= немедленно останавливает цикл и возвращает
          /value/. Форма =(loop-finish)= останавливает цикл, вычисляя
          подвыражения =finally=, и возвращает все накопленные значения.

          Циклу можно назначить имя -- =(loop named name
          clauses...)=. Из такого цикла можно выйти с помощью
          =(return-from name [value])=. (Если уточнить, то loop
          устанавливает неявный block с заданным именем, или с именем
          =nil=.)

       7. [[http://www.lispworks.com/reference/HyperSpec/Body/06_abb.htm][Local variable clauses]]

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop with s = "david pierce"
                  for prev = (char s 0) then next
                  for next across (subseq s 1)
                  do (format t "~a came before ~a~%" prev next))
            #+END_EXAMPLE
          #+END_QUOTE

          =With= clauses are normally initialized sequentially.
          Variables can be initialized in parallel by connecting the
          clauses with =and= rather than =with=.

       I'll conclude this lesson with a few additional points about
       loops.

       -  As we have seen, termination conditions can arise in several
          places -- iteration control clauses, termination test clauses,
          and even uses of =return= and =loop-finish=. Just to clarify,
          a loop terminates when its /first/ termination condition is
          satisfied. Depending on the type of termination, the loop may
          or may not return a value, and may or may not execute the
          finally clauses.

       -  Although =loop= is quite flexible about the order of clauses,
          the order is not completely free. The general rule is the
          "variable" clauses come before "action" clauses. The
          "variable" clauses are the interation control and =with=
          clauses. The "action" clauses are the execution, value
          accumulation, and termination test clauses. Initial-final
          clauses may occur anywhere.

       7. Локальные переменные

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (loop with s = "дэвид пирс"
                  for prev = (char s 0) then next
                  for next across (subseq s 1)
                  do (format t "~a came before ~a~%" prev next))
            #+END_EXAMPLE
          #+END_QUOTE

          Подвыражения =with= обычно инициализируются последовательно.
          Для параллельной инициализации необходимо использовать
          =and=.

       Автор завершает данный урок дополнительными словами о циклах.

       - Как мы увидели, завершение цикла может произойти в
         нескольких местах -- в управлении итерациями, в проверке
         завершения, и при использовании =return= и =loop-finish=. 
         Цикл завершает при выполнении /первого/ из этих выражений. В
         зависимости от завершения, цикл может вернуть или не вернуть
         значение, и выполнить или не выполнить последние выражения.

       - Кроме того =loop= достаточно гибкий в порядке расположения
         подвыражений. Главное правило в том, что выражения "для
         переменных" должны идти перед выражениями "для выполнения".
         Выражения "для переменных" это управление итерациями и
         локальные переменные. Выражения "для выполнения" это
         выполнение, накопление значения и проверка
         завершения. Первые-последние выражения могут быть в любом
         месте.

   23. Assignment Присваивание

       -  Globals  :: 

          #+BEGIN_QUOTE
            =(defconstant name initial-value [documentation])=
             Illegal to change value.

            =(defparameter name initial-value [documentation])=

            =(defvar name [initial-value [documentation]])=
             Won't reinitialize the variable.
          #+END_QUOTE

          #+BEGIN_QUOTE
            =(defconstant name initial-value [documentation])=
              Невозможно изменить значение
          
            =(defparameter name initial-value [documentation])=

            =(defvar name [initial-value [documentation]])=
             Невозможно переинициализировать переменную. 
          #+END_QUOTE

          Usual style is to name globals =*var*=

          Стиль именования глобальных переменных =*var*=

          Try:

          Попробуйте сами:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defconstant *Lab* 'Baldy\ 19
                  "Where we meet.")
                *Lab*
                (defconstant *Lab* 'Baldy\ 21
                  "Where we meet.")
                *Lab*
                (defparameter *Time* "TTh 1:30-2:30"
                  "Time of our meeting")
                *Time*
                (defparameter *Time* "MTh 10:30-1:30"
                  "Time of our meeting")
                *Time*
                (defvar *Attendance* 20
                  "The number of students attending")
                *Attendance*
                (defvar *Attendance* 6
                  "The number of students attending")
                *Attendance*
            #+END_EXAMPLE
          #+END_QUOTE

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defconstant *Lab* 'Baldy\ 19
                  "Где мы встречаемся.")
                *Lab*
                (defconstant *Lab* 'Baldy\ 21
                  "Где мы встречаемся.")
                *Lab*
                (defparameter *Time* "TTh 1:30-2:30"
                  "Время встречи")
                *Time*
                (defparameter *Time* "MTh 10:30-1:30"
                  "Время встречи")
                *Time*
                (defvar *Attendance* 20
                  "Количество студентов")
                *Attendance*
                (defvar *Attendance* 6
                  "Количество студентов")
                *Attendance*
            #+END_EXAMPLE
          #+END_QUOTE


       -  Assignment Присваивание  :: 
                 
          #+BEGIN_QUOTE
            =(=[[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/set.htm][set]]
            =symbol value)=
             Evaluates both arguments.

            =(=[[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/setq.htm][setq]]
            ={symbol value}*)=
             Doesn't evaluate =symbol=. *Old fashioned.*

            =(=[[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/setfpset.htm][setf]]
            ={place value}*)=
             Uses l-value of =place=. Sequential.

            =(=[[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/setfpset.htm][psetf]]
            ={place value}*)=
             Uses l-value of =place=. Parallel.
          #+END_QUOTE

          #+BEGIN_QUOTE
            =(set symbol value)=
             Выполняет оба аргумента.

            =(setq {symbol value}*)=
             Не выполняет выражение =symbol=. *Старый стиль.*

           =(setf {place value}*)=
          Использует l-value выражения =place=. Последовательно.

            =(psetf {place value}*)=
          Использует l-value выражения =place=. Параллельно.
          #+END_QUOTE

          Try:

          Попробуйте сами:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (setf *Lab* 'Baldy\ 19)
                (setf *Time* "TTh 10:30-1:30"
                      *Attendance* 10)
                *Time*
                *Attendance*

                (setf x 3 y 5) ; Don't assign to new global variables in a function body
                x
                y
                (psetf x y y x)
                x
                y
            #+END_EXAMPLE
          #+END_QUOTE

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (setf *Lab* 'Baldy\ 19)
                (setf *Time* "TTh 10:30-1:30"
                      *Attendance* 10)
                *Time*
                *Attendance*

                (setf x 3 y 5) ; Не присваивайте Don't assign to new global variables in a function body
                x
                y
                (psetf x y y x)
                x
                y
            #+END_EXAMPLE
          #+END_QUOTE


       -  Places  :: May be a symbol, or a wide variety of specifiers of
          [[http://www.franz.com/support/documentation/8.1/ansicl/section/generali.htm][generalized reference]]s.
           For example:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (setf x '(a b c d e))
                (setf (second x) 2)
                x

                (setf addresses (make-hash-table))
                (setf (gethash 'Stu addresses) 'shapiro@cse.buffalo.edu)
                (setf (gethash 'David addresses) 'drpierce@cse.buffalo.edu)
                (setf (gethash 'Luddite addresses) nil)
                (gethash 'David addresses)
                (gethash 'Stu addresses)
                (gethash 'Luddite addresses)
                (gethash 'Bill addresses)
            #+END_EXAMPLE
          #+END_QUOTE

          But be careful:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defun goodTimers (folks)
                   (append folks '(had a good time)))
                (setf list1 (goodTimers '(Trupti Mike and Fran)))
                (setf (seventh list1) 'bad)
                list1
                (goodTimers '(Jon Josephine and Orkan))
            #+END_EXAMPLE
          #+END_QUOTE

       And don't get carried away. Experienced Lispers use =setf= very
       infrequently.

       Some useful globals

       =*=

       The last object returned by the Lisp listener.

       =**=

       The second-last object returned by the Lisp listener.

       =***=

       The third-last object returned by the Lisp listener.

       =*package*=

       The current package.

       =*print-base*=

       Numeric base to be used when printing numbers.

       =*read-base*=

       Numeric base to be used when reading numbers.

       ==

       ==

       =tpl:*print-length*=

       The maximum length of lists printed at the top level; if =nil=,
       no limit.

       =tpl:*print-level*=

       The maximum depth of lists printed at the top level; if =nil=, no
       limit.

       Exercise: Turn the Lisp listener into a converter from
       hexidecimal notation to binary notation. Then put it back.

   24. Sequential Execution Последовательное выполнение

       Now that we've looked at assignment, we might as well see the
       other essential imperative construct -- sequencing. Actually
       there's nothing new here, because many Lisp forms allow a
       sequence of expressions in the "body" of the form. This is true
       of defun, cond, and let, for example.

       Сейчас, когда мы рассмотрели присваивание, мы может
       рассмотреть другую императивную конструкцию --
       последовательное выполнение. Здесь нет ничего нового, потому
       что многие Lisp'овые формы позволяют выполнять
       последовательности выражений в "теле" формы. Например, это формы defun,
       cond и let.

       Remember also that we told you in passing that the sequence of
       expressions forming the body of such a construct was called an
       "implicit progn". That's because
       [[http://www.lispworks.com/reference/HyperSpec/Body/s_progn.htm][progn]]
       is the Lisp expression for enclosing an /explicit/ sequence of
       expressions. The result of a progn is the value of the last
       expression; it discards the results of the others.

       Вспомните, что мы называли последовательность выражений в
       "теле" как неявный progn. Это потому, что неявный progn
       является Lisp'овой формой, для создания /явной/
       последовательности выражений. Результатом формы progn является
       значение последнего выражения. Значения всех остальных
       выражений игнорируются.

       You won't need to use progn very much, since most of the usual
       hangouts for sequences of expressions are already implicit
       progns. However, there are a couple of interesting variations of
       progn that are occasionally handy, namely
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_prog1c.htm][prog1 and prog2]].

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (prog1 1 2 3)
             (prog2 1 2 3)
             (progn 1 2 3)
         #+END_EXAMPLE
       #+END_QUOTE

       Обычно использовать progn нет необходимости, так как
       большинство конструкций создают неявный progn. Однако
       существует набор интересных вариаций progn, которые иногда
       бывают удобны: prog1 и prog2.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (prog1 1 2 3)
             (prog2 1 2 3)
             (progn 1 2 3)
         #+END_EXAMPLE
       #+END_QUOTE

   25. Functions Функции

       We already know quite a bit about functions -- at least, named
       functions.

       -  Named functions are defined by =defun= forms.
       -  Functions are called by evaluating a list form whose first
          element is the function name --
          =(function-name argument ...)=.
       -  The form =(function function-name)= can be used to
          obtain a function object for a name. =#'function-name= is an
          abbreviation for =(function function-name)=.

       Мы уже знаем кое-что о функциях -- как минимум, об именованных
       функция.

       - Именованные функции создаются с помощью формы =defun=.
       - Функции вызываются с помощью выполнения списка, в котором в
         первом элементе указано имя функции -- =(function-name
         argument ...)=.
       - Форма =(function function-name)= может использоваться для
         получения объекта функции, имея только имя. Выражение
         =#'function-name= является аббревиатурой для =(function
         function-name)=.

       What can we do with function objects in Lisp?

       -  Functions can be bound to variables, passed as arguments, and
          stored in data structures, just like other Lisp objects.
          Functions with these abilities are often referred to as "first
          class functions".
       -  Functions can be called on arguments /argument/_{1} ...
          /argument/_{n} using the form
          =(funcall function argument1 ... argumentn)=.
       -  Functions can be called on arguments /argument/_{1} ...
          /argument/_{n} using the form
          =(apply function argument1 ... argumentm-1 argumentsm...n)=,
          where /arguments/_{m...n} is a list of arguments /m/ through
          /n/.

       Что в Lisp'е мы можем сделать с объектами функции?

       -  Функции могут быть присвоены переменными, переданы как
          аргументы, и сохранены в структурах данных, просто как
          любые другие Lisp'овые объекты.
          Функции с такими свойствами, часто называются "функции
          высшего порядка".
       -  Функции могут применяться к аргументам argument/_{1} ...
          /argument/_{n} с помощью формы 
          =(funcall function argument1 ... argumentn)=.
       -  Функции также могут применяться к аргументам с помощью
          формы =(apply function argument1 ... argumentm-1
          argumentsm...n)=, где /arguments/_{m...n} является списком
          аргументов от /m/ до /n/.

       Some examples we've already seen:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (member '(a c) '((a b) (a c) (b c)) :test #'equal)

             (loop for x in '(a b c d e) by #'cddr do (print x))
         #+END_EXAMPLE
       #+END_QUOTE

       Некоторые примеры, которые мы уже видели:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (member '(a c) '((a b) (a c) (b c)) :test #'equal)

             (loop for x in '(a b c d e) by #'cddr do (print x))
         #+END_EXAMPLE
       #+END_QUOTE

       Some new examples:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (funcall #'cons nil nil)

             (setf some-functions (list #'third #'first #'second))

             (funcall (first some-functions) '(a b c))

             (defun multicall (list-of-functions &rest arguments)
               "Returns a list of results obtained by calling each function
             in LIST-OF-FUNCTIONS on the ARGUMENTS."
               (loop for f in list-of-functions
                 collect (apply f arguments)))

             (multicall (list #'third #'second #'first) '(a b c))
         #+END_EXAMPLE
       #+END_QUOTE

       Парочка новых:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (funcall #'cons nil nil)

             (setf some-functions (list #'third #'first #'second))

             (funcall (first some-functions) '(a b c))

             (defun multicall (list-of-functions &rest arguments)
               "Returns a list of results obtained by calling each function
             in LIST-OF-FUNCTIONS on the ARGUMENTS."
               (loop for f in list-of-functions
                 collect (apply f arguments)))

             (multicall (list #'third #'second #'first) '(a b c))
         #+END_EXAMPLE
       #+END_QUOTE

       Exercise: Define a function
       =(tree-member item tree &key (key #'identity) (test #'eql))=
       that returns the subtree of a labeled /tree/ rooted at /item/,
       like =member= does for lists. A labeled tree node is represented
       as =(label . children)= where /children/ is a list of nodes. Leaf
       nodes have empty child lists. An /item/ is regarded as equal to a
       label of /tree/ when =(test item (key label))= is true. For
       example:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (tree-member "feline"
               '("animal"
                 ("mammal"
                  ("feline" ("lion") ("tiger") ("kitty"))
                  ("rodent" ("squirrel") ("bunny") ("beaver")))
                 ("bird" ("canary") ("pigeon"))
                 ("reptile" ("turtle") ("snake")))
               :test #'string=)
             ==> ("feline" ("lion") ("tiger") ("kitty"))
         #+END_EXAMPLE
       #+END_QUOTE

       Упражнение: Определите функцию =(tree-member item tree &key
       (key #'identity) (test #'eql))=, которая возвращает поддерево
       дерева /tree/ с отметками и с корнем /item/, также как =member=
       работает для списков. Дерево с отметкой выглядит так =(label
       . children)=, где /children/ является списком дочерних
       элементов. Листья не имеют дочерних элементов. /item/
       эквивалентно отметке дерева /tree/, если =(test item (key
       label))= истина. Например:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (tree-member "feline"
               '("animal"
                 ("mammal"
                  ("feline" ("lion") ("tiger") ("kitty"))
                  ("rodent" ("squirrel") ("bunny") ("beaver")))
                 ("bird" ("canary") ("pigeon"))
                 ("reptile" ("turtle") ("snake")))
               :test #'string=)
             ==> ("feline" ("lion") ("tiger") ("kitty"))
         #+END_EXAMPLE
       #+END_QUOTE

       Since function objects can be used so flexibly in Lisp, it makes
       sense that we should be able to create a function without having
       to define a named function; that is, use a throwaway function
       instead of a permanent defun. That's what
       [[http://www.lispworks.com/reference/HyperSpec/Body/s_lambda.htm][lambda]]
       is for. A "lambda expression" can be used in place of a function
       name to obtain a function.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             #'(lambda (x) (+ x 1))

             ((lambda (x) (+ x 1)) 42)

             (funcall #'(lambda (x) (+ x 1)) 42)
         #+END_EXAMPLE
       #+END_QUOTE

       Так как объекты функции могут так гибко использоваться, значит
       возможно, что мы можем создать функцию не задавая для неё
       имени. И ведь да, это делается с помощью формы
       =lambda=. Лямбда-выражение может быть использовано вместо
       имени функции.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             #'(lambda (x) (+ x 1))

             ((lambda (x) (+ x 1)) 42)

             (funcall #'(lambda (x) (+ x 1)) 42)
         #+END_EXAMPLE
       #+END_QUOTE
       

       Note that

       =((lambda lambda-list . body) . arguments)= ==
       =(funcall #'(lambda lambda-list . body) . arguments)=.

       In fact, the =function= form isn't really necessary, because
       =lambda= is set up so that

       =(lambda lambda-list . body)= ==
       =#'(lambda lambda-list . body)=.

       Следует отметить, что 

       =((lambda lambda-list . body) . arguments)= ==
       =(funcall #'(lambda lambda-list . body) . arguments)=.

       А фактически форма =function= не является необходимой, потому
       что =lambda= сделана так, что:

       =(lambda lambda-list . body)= ==
       =#'(lambda lambda-list . body)=.

       Lambda functions are actually /closures/, which means that they
       comprise not only their code, but also their lexical environment.
       So they "remember" variable bindings established at the time of
       their creation.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun make-adder (delta)
               (lambda (x) (+ x delta)))

             (setf f (make-adder 13))
             (funcall f 42)

             (funcall (make-adder 11) (funcall (make-adder 22) 33))
         #+END_EXAMPLE
       #+END_QUOTE

       Лямбда-функции также являются /замыканиями/, что означает, что
       в них хранится не только их код, но и также лексическое
       окружение.
       Таким образом они запоминают связывания переменных, сделанные
       во время создания этой лямбда-функции.

       Exercise: Define a function =(compose f g)= that composes
       functions /f/ and /g/. Assume that /f/ composed with /g/ is
       defined as (/f • g/)(x) = /f/(/g/(/x/)). Try
       =(funcall (compose #'char-upcase #'code-char) 100)=.

       Упражнение: Определите функцию =(compose f g)=, которая
       компонует функции /f/ и /g/.  Допустим, что компоновка /f/ с
       /g/ выглядит как (/f • g/)(x) = /f/(/g/(/x/)). Попробуйте 
       =(funcall (compose #'char-upcase #'code-char) 100)=.

   26. Mapping

       It is common to want to apply a function to every element of a
       list and obtain the results of each of the calls. This operation
       is called
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_mapc_.htm][mapping]].
       Lambda expressions tend to be quite useful in mapping.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (mapcar #'(lambda (s) (string-capitalize (string s))) '(fee fie foe fum))

             (maplist #'reverse '(a b c d e))

             (mapcar #'(lambda (s n) (make-list n :initial-element s))
                 '(a b c d e) '(5 2 3 7 11))

             (mapcan #'(lambda (s n) (make-list n :initial-element s))
                 '(a b c d e) '(5 2 3 7 11))

             (mapcon #'reverse '(a b c d e))
         #+END_EXAMPLE
       #+END_QUOTE

   27. Отображение

       Частенько бывает нужно применить функцию к каждому элементу
       списка и получить результаты каждого вызова. Эта операция
       называется отображение.
       Лямбда-функции в этом смысле очень удобны.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (mapcar #'(lambda (s) (string-capitalize (string s))) '(fee fie foe fum))

             (maplist #'reverse '(a b c d e))

             (mapcar #'(lambda (s n) (make-list n :initial-element s))
                 '(a b c d e) '(5 2 3 7 11))

             (mapcan #'(lambda (s n) (make-list n :initial-element s))
                 '(a b c d e) '(5 2 3 7 11))

             (mapcon #'reverse '(a b c d e))
         #+END_EXAMPLE
       #+END_QUOTE

   27. Sequences Последовательности

       [[http://www.lispworks.com/reference/HyperSpec/Body/17_.htm][Sequence]]
       is the common superclass of lists and vectors (i.e.,
       one-dimensional arrays) -- one-dimensional ordered collections of
       objects. Sequences also support mapping.

       Последовательности -- это общий суперкласс (родительский) для
       списком и векторов (то есть одномерных массивов), или одномерные
       упорядоченные коллекции объектов. Последовательности также
       поддерживают отображения.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (map 'list #'(lambda (c) (position c "0123456789ABCDEF")) "2BAD4BEEF")

             (map 'string #'(lambda (a b) (if (char< a b) a b))
                  "David Pierce" "Stu Shapiro")
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (map 'list #'(lambda (c) (position c "0123456789ABCDEF")) "2BAD4BEEF")

             (map 'string #'(lambda (a b) (if (char< a b) a b))
                  "Дэвид Пирс" "Стью Шапиро")
         #+END_EXAMPLE
       #+END_QUOTE

       Here are examples of other useful
       [[http://www.lispworks.com/reference/HyperSpec/Body/17_a.htm][functions on sequences]]. Many of these take functions as
       arguments.

       Вот ещё примерчик полезных функций для
       последовательностей. Многие из них принимают функции в
       качестве аргументов.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (count-if #'oddp '(2 11 10 13 4 11 14 14 15) :end 5)

             (setf x "David Pierce")
             (sort x #'(lambda (c d)
                     (let ((m (char-code c)) (n (char-code d)))
                       (if (oddp m)
                             (if (oddp n) (< m n) t)
                         (if (oddp n) nil (< m n))))))
             ;; note that SORT does destructive modification
             x

             (find-if
              #'(lambda (c) (= (* (first c) (first c)) (second c)))
              '((1 3) (3 5) (5 7) (7 9) (2 4) (4 6) (6 8)))

             (position-if
              #'(lambda (c) (= (* (first c) (first c)) (second c)))
              '((1 3) (3 5) (5 7) (7 9) (2 4) (4 6) (6 8)))

             (reduce #'+ '(1 2 3 4))
             (reduce #'list '(a b c d e))
             (reduce #'list '(a b c d e) :initial-value 'z)
             (reduce #'list '(a b c d e) :from-end t)
             (reduce #'append '((a b) (c d) (e f g) (h) (i j k)))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (count-if #'oddp '(2 11 10 13 4 11 14 14 15) :end 5)

             (setf x "David Pierce")
             (sort x #'(lambda (c d)
                     (let ((m (char-code c)) (n (char-code d)))
                       (if (oddp m)
                             (if (oddp n) (< m n) t)
                         (if (oddp n) nil (< m n))))))
             ;; note that SORT does destructive modification
             x

             (find-if
              #'(lambda (c) (= (* (first c) (first c)) (second c)))
              '((1 3) (3 5) (5 7) (7 9) (2 4) (4 6) (6 8)))

             (position-if
              #'(lambda (c) (= (* (first c) (first c)) (second c)))
              '((1 3) (3 5) (5 7) (7 9) (2 4) (4 6) (6 8)))

             (reduce #'+ '(1 2 3 4))
             (reduce #'list '(a b c d e))
             (reduce #'list '(a b c d e) :initial-value 'z)
             (reduce #'list '(a b c d e) :from-end t)
             (reduce #'append '((a b) (c d) (e f g) (h) (i j k)))
         #+END_EXAMPLE
       #+END_QUOTE

       Exercise: Suppose you are given a list of headings for the
       columns of a table -- for example,
       =("Function " "Arguments " "Return values " "Author " "Version ")=.
       The size of the columns are determined by the length of these
       headings. Write an expression to compute the number of spaces to
       insert to place text into the /n/^{th} column of the table.

       Упражнение: Представьте, что вы получили список заголовков для
       столбцов таблицы -- например, =("Function " "Arguments "
       "Return values " "Author " "Version ")=.  Размер столбцов
       вычисляется с помощью длин этих заголовков. Напишите,
       выражение, которые вычисляет количество пробелов (или
       количество места) для вставки в /n/-нный столбец таблицы.

   28. Input/Output Ввод/Вывод

       I/O in Lisp is based on
       [[http://www.lispworks.com/reference/HyperSpec/Body/21_aa.htm][streams]].
       A stream is a source or destination for characters or bytes. For
       example, streams can be directed to or from files, strings, or
       the terminal. Output functions (e.g., =format= and =print=) and
       input functions (e.g., =read=) normally take stream arguments;
       although frequently the stream argument is optional. Several
       streams are available when Lisp starts up, including
       =*standard-input*= and =*standard-output*=. If the session is
       interactive, both of these are the same as =*terminal-io*=.

       Ввод/вывод (чтение/запись) в Lisp'е основан на потоках. Поток
       это источник или приёмник строковых символов или
       байтов. Например, поток может быть направлен в или из файла,
       строки или терминала. Поток в качестве необязательного
       аргумента принимают функции вывода (записи) (например, =format=
       и =print=) и функции ввода (чтения) (например, read). При
       запуске Lisp'а доступны несколько стандартных потоков, включая
       =*standard-input*=, =*standard-output*=. Если сессия
       интерактивна, они оба являются синонимами для =*terminal-io*=.

       The basic output functions for streams are
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_cha.htm][write-char]]
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_stg.htm][write-line]].
       The basic input functions are
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_rd_cha.htm][read-char]]
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_rd_lin.htm][read-line]].

       Основными функциями вывода (записи) являются =write-char= и
       =write-line=. Основными функциями ввода (чтения) являются
       =read-char= и =read-line=.

       File streams are created by the
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_open.htm][open]]
       function. However, it is more convenient to use the
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_w_open.htm][with-open-file]]
       form, which ensures that the file is closed regardless of whether
       control leaves normally or abnormally.

       Файловые потоки создаются с помощью функции =open=. Однако,
       удобнее использовать форму =with-open-file=, которая
       обязательно закроет файл в конце вне зависимости от того,
       возникла ли ошибка или нет в процессе работы с ним.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-open-file (output-stream "/tmp/drpierce.txt" ; put your name here
                              :direction :output)
               (write-line "I like Lisp" output-stream))

             (with-open-file (input-stream "/tmp/drpierce.txt" :direction :input)
               (read-line input-stream))

             (with-open-file (output-stream "/tmp/drpierce.txt" 
                              :direction :output
                              :if-exists :supersede)
               (write-line "1. Lisp" output-stream))

             (with-open-file (output-stream "/tmp/drpierce.txt" 
                              :direction :output
                              :if-exists :append)
               (write-line "2. Prolog" output-stream)
               (write-line "3. Java" output-stream)
               (write-line "4. C" output-stream))

             ;; read lines until eof
             (with-open-file (input-stream "/tmp/drpierce.txt" :direction :input)
               (loop for line = (read-line input-stream nil nil)
                 while line
                 collect line))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-open-file (output-stream "/tmp/drpierce.txt" ; укажите здесь своё имя
                              :direction :output)
               (write-line "Я люблю Lisp" output-stream))

             (with-open-file (input-stream "/tmp/drpierce.txt" :direction :input)
               (read-line input-stream))

             (with-open-file (output-stream "/tmp/drpierce.txt" 
                              :direction :output
                              :if-exists :supersede)
               (write-line "1. Lisp" output-stream))

             (with-open-file (output-stream "/tmp/drpierce.txt" 
                              :direction :output
                              :if-exists :append)
               (write-line "2. Prolog" output-stream)
               (write-line "3. Java" output-stream)
               (write-line "4. C" output-stream))

             ;; чтение строк до конца файла
             (with-open-file (input-stream "/tmp/drpierce.txt" :direction :input)
               (loop for line = (read-line input-stream nil nil)
                 while line
                 collect line))
         #+END_EXAMPLE
       #+END_QUOTE

       Similarly, a string stream is usually manipulated using
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_w_out_.htm][with-output-to-string]]
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/m_w_in_f.htm][with-input-from-string]].

       Подобным образом, строковый поток обычно управляется с
       помощью =with-output-to-string= и =with-input-from-string=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-output-to-string (output-stream)
               (loop for c in '(#\L #\i #\s #\p)
                 do (write-char c output-stream)))

             (with-input-from-string (input-stream "1 2 3 4 5 6 7 8 9")
               (loop repeat 10 collect (read-char input-stream)))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-output-to-string (output-stream)
               (loop for c in '(#\L #\i #\s #\p)
                 do (write-char c output-stream)))

             (with-input-from-string (input-stream "1 2 3 4 5 6 7 8 9")
               (loop repeat 10 collect (read-char input-stream)))
         #+END_EXAMPLE
       #+END_QUOTE

       Although the basic I/O functions are available, you will normally
       invoke the higher-level capabilities of the
       [[http://www.lispworks.com/reference/HyperSpec/Body/22_.htm][Lisp printer]] and the
       [[http://www.lispworks.com/reference/HyperSpec/Body/23_.htm][Lisp reader]]. We discuss the printer and reader in the following
       sections.

       Кроме базовых функций ввода/вывода, вы можете использовать
       высокоуровневый функционал Lisp'овых считывателя и
       печатальщика. Мы рассмотрим их в следующих разделах.

       Streams are closed using
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_close.htm][close]].
       Other stream functions include
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_stmp.htm][streamp]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_open_s.htm][open-stream-p]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_listen.htm][listen]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_peek_c.htm][peek-char]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_clear_.htm][clear-input]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_finish.htm][finish-output]].

       Потоки закрываются с помощью функции =close=.
       Другие функции для потоков включают
       =streamp=, =open-stream-p=, =listen=, =peek-char=,
       =clear-input=, =finish-output=.

   29. The Printer Lisp'овый печатальщик

       The standard entry point into the printer is the function
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm][write]];
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm][prin1]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm][princ]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm][print]],
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_pr.htm][pprint]]
       are wrappers for certains settings of =write=. The optional
       output stream argument of each of these functions defaults to
       standard output. Another useful set of print functions is
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm][write-to-string]],
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm][prin1-to-string]],
       and
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_wr_to_.htm][princ-to-string]].

       Самая главная функция для вывода это =write=.
       Функции =prin1=, =princ=, =print=, =pprint= являются обёрткой
       для =write=. Необязательный аргумент потока в каждой из этих
       функции по умолчанию равен стандартному потоку вывода. Ещё
       один полезный набор функций это =write-to-string=,
       =prin1-to-string= и =princ-to-string=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (setf z
               '("animal"
                 ("mammal"
                  ("feline" ("lion") ("tiger") ("kitty"))
                  ("ursine" ("polar bear") ("teddy bear"))
                  ("rodent" ("squirrel") ("bunny") ("beaver")))
                 ("bird" ("canary") ("pigeon"))
                 ("reptile" ("turtle") ("snake"))))
             (prin1 z) ;; same as (write z :escape t)
             (princ z) ;; same as (write z :escape nil :readably nil)
             (write z :escape nil :pretty t :right-margin 40)
             (write-to-string z :escape nil :pretty nil)
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (setf z
               '("животные"
                 ("млекопитающие"
                  ("кошачие" ("лев") ("тигр") ("котенок"))
                  ("медведи" ("полярный медведь") ("серый медведь"))
                  ("грызуны" ("белка") ("кролик") ("бобёр")))
                 ("птицы" ("канарейка") ("голубь"))
                 ("рептилии" ("черепаха") ("змея"))))
             (prin1 z) ;; эквивалентно (write z :escape t)
             (princ z) ;; эквивалентно (write z :escape nil :readably nil)
             (write z :escape nil :pretty t :right-margin 40)
             (write-to-string z :escape nil :pretty nil)
         #+END_EXAMPLE
       #+END_QUOTE

       A more sophisticated and flexible aspect of the printer is the
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_format.htm#format][format]]
       function --
       =(format destination control-string argument...)=. This
       function consults the /control-string/ to determine how to format
       the remaining /argument/s (if any) and transfers the output to
       /destination/.

       Более сложная и гибкая функция вывода это =format= -- =(format
       destination control-string argument...)=. Эта функция с помощью
       управляющей строки /control-string/ определяет то, как
       необходимо вывести аргументы /argument/ (если они были) и
       выводит в /destination/.

       | If /destination/ is: | then the output:               |
       | =t=                  | appears on the standard output |
       | a stream             | appears on that stream         |
       | =nil=                | is returned as a string        |

       | Если /destination/: | тогда вывод:               |
       | =t=                 | в стандартный поток        |
       | поток               | в указанный поток          |
       | =nil=               | будет возвращён как строка |
       

       The control string consists of simple text, with embedded format
       control directives. Some of the simpler, more commonly used
       directives are summarized below.

       Управляющая строка представляет собой простой текст с
       управляющими директивами. Некоторые из них,
       частоиспользуемые, перечислены ниже.

       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cdc.htm][~W]]                   | format as if by =write=; any kind of object; obey every printer control variable                                       |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cdb.htm][~S]]                   | format as if by =prin1=; any kind of object; "standard" format                                                         |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cda.htm][~A]]                   | format as if by =princ=; any kind of object; human readable ("asthetic") format                                        |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbb.htm][~D]] (or [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbc.htm][B]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbd.htm][O]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbe.htm][X]])      | decimal (or binary, octal, hex) integer format                                                                         |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cca.htm][~F]] (or [[http://www.lispworks.com/reference/HyperSpec/Body/22_ccb.htm][E]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_ccc.htm][G]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_ccd.htm][$]])      | fixed-format (or exponential, general, monetary) floating-point format                                                 |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cgd.htm][~{]]/control-string/~} | format a list; repeatedly uses /control-string/ to format elements of the list until the list is exhausted             |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cab.htm][~%]]                   | print a newline                                                                                                        |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cac.htm][~&]]                   | print a newline unless already at the beginning of the line                                                            |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cae.htm][~~]]                   | print a (single) tilde                                                                                                 |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cga.htm][~*]]                   | ignore the corresponding argument                                                                                      |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cic.htm][~/newline/]]           | ignore the newline and any following whitespace (allows long format control strings to be split across multiple lines) |

       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cdc.htm][~W]]                   | вывод как =write=; любой объект; obey every printer control variable                                                            |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cdb.htm][~S]]                   | вывод как =prin1=; любой объект; "стандартный" формат                                                                           |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cda.htm][~A]]                   | вывод как =princ=; любой объект; человекочитаемый формат                                                                        |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbb.htm][~D]] (or [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbc.htm][B]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbd.htm][O]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_cbe.htm][X]])      | десятичный (или бинарный, восьмеричный, шестнадцатиричный) формат числа                                                         |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cca.htm][~F]] (or [[http://www.lispworks.com/reference/HyperSpec/Body/22_ccb.htm][E]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_ccc.htm][G]], [[http://www.lispworks.com/reference/HyperSpec/Body/22_ccd.htm][$]])      | фиксированный (экспоненциальный, общий, денежный) формат числа с плавающей точкой                                               |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cgd.htm][~{]]/control-string/~} | вывод списка; циклично использует управляющую строку /control-string/ для форматирования элементов списка пока он не закончится |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cab.htm][~%]]                   | перевод строки                                                                                                                  |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cac.htm][~&]]                   | перевод строки, но только если текущая не пустая                                                                                |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cae.htm][~~]]                   | вывод тильды                                                                                                                    |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cga.htm][~*]]                   | игнорирование текущего элемента                                                                                                 |
       | [[http://www.lispworks.com/reference/HyperSpec/Body/22_cic.htm][~/newline/]]           | игнорировать перевод строки и любый последующие пробелы (позволяет разбивать длинные управляющие строки на несколько)           |

       Many format control directives accept "arguments" -- additional
       numbers or special characters between the ~ and the directive
       character. For example, a common argument allowed by many
       directives is a column width. See the documentation for
       individual directives for details about their arguments. In place
       of an "argument" in the control string, the character =v=
       indicates the next =format= argument; while the character =#=
       denotes the number of remaining =format= arguments.

       Многие управляющие директивы принимают "аргументы" --
       дополнительные числа или специальные символы между ~ и самой
       последовательностью. Например, аргумент для многих директив
       указывает ширину столбца. Для подробностей смотрите
       документацию для каждой директивы.  В месте "аргумента" для
       директивы, символ =v= обозначает следующий аргумент функции
       =format=, тогда как символ =#= обозначает число предыдущих
       аргументов функции =format=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             ;; format an invoice
             (loop for (code desc quant price) in
               '((42 "House" 1 110e3) (333 "Car" 2 15000.99) (7 "Candy bar" 12 1/4))
               do (format t "~3,'0D ~10A ~3D @ $~10,2,,,'*F~%" code desc quant price))

             (defun char-* (character number)
               "Returns a string of length NUMBER filled with CHARACTER."
               (format nil "~v,,,vA" number character ""))
             ;; but (make-string number :initial-element character) is better

             ;; format an invoice again, one-liner
             (format t "~:{~3,'0D ~10A ~3D @ $~10,2,,,'*F~%~}"
              '((42 "House" 1 110e3) (333 "Car" 2 15000.99) (7 "Candy bar" 12 1/4)))

             ;; comma-separated list
             (loop for i from 1 to 4 do
               (format t "~{~A~^, ~}~%" (subseq '(1 2 3 4) 0 i)))

             ;; comma-separated list again, but cleverer
             ;; (using things I didn't mention above :-)
             (loop for i from 1 to 4 do
               (format t "~{~A~#[~; and ~:;, ~]~}~%" (subseq '(1 2 3 4) 0 i)))

             (loop for i from 1 to 4 do
               (format t "~{~A~#[~;~:;,~]~@{~#[~; and ~A~:; ~A,~]~}~}~%"
                   (subseq '(1 2 3 4) 0 i)))

             ;; format an invoice again, but cleverer
             ;; with commas in the prices
             (loop for (code desc quant price) in
               '((42 "House" 1 110e3) (333 "Car" 2 15000.99) (7 "Candy bar" 12 1/4))
               do (format t "~3,'0d ~10a ~3d @ ~{$~7,'*:D~3,2F~}~%"
                      code desc quant (multiple-value-list (floor price))))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             ;; format an invoice
             (loop for (code desc quant price) in
               '((42 "Дом" 1 110e3) (333 "Автомобиль" 2 15000.99) (7 "Конфета" 12 1/4))
               do (format t "~3,'0D ~10A ~3D @ $~10,2,,,'*F~%" code desc quant price))

             (defun char-* (character number)
               "Возвращает строку длинной NUMBER заполненную символами CHARACTER."
               (format nil "~v,,,vA" number character ""))
             ;; но (make-string number :initial-element character) лучше

             ;; вывод счёта ещё раз в одну строку
             (format t "~:{~3,'0D ~10A ~3D @ $~10,2,,,'*F~%~}"
              '((42 "Дом" 1 110e3) (333 "Автомобиль" 2 15000.99) (7 "Конфета" 12 1/4)))

             ;; список с запятыми-разделителями
             (loop for i from 1 to 4 do
               (format t "~{~A~^, ~}~%" (subseq '(1 2 3 4) 0 i)))

             ;; опять список с запятыми разделителями, но умнее
             ;; (использует фичи, которые мы не рассматривали
             (loop for i from 1 to 4 do
               (format t "~{~A~#[~; и ~:;, ~]~}~%" (subseq '(1 2 3 4) 0 i)))

             (loop for i from 1 to 4 do
               (format t "~{~A~#[~;~:;,~]~@{~#[~; and ~A~:; ~A,~]~}~}~%"
                   (subseq '(1 2 3 4) 0 i)))

             ;; опять вывод счёта, но умнее
             ;; с запятыми в ценах
             (loop for (code desc quant price) in
               '((42 "Дом" 1 110e3) (333 "Автомобиль" 2 15000.99) (7 "Конфета" 12 1/4))
               do (format t "~3,'0d ~10a ~3d @ ~{$~7,'*:D~3,2F~}~%"
                      code desc quant (multiple-value-list (floor price))))
         #+END_EXAMPLE
       #+END_QUOTE

       Exercise: Define
       =(print-properties plist &optional stream)= to print a
       propery list to /stream/ as shown below. The /stream/ should
       default to =*standard-output*=.

       Упражнение: Создайте =(print-properties plist &optional
       stream)= для вывода списка свойств в поток /stream/ как
       показано ниже. Поток /stream/ по-умолчанию должен быть равен
       =*standard-output*=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (print-properties '(course CSE-202 semester "Summer 2004"
                         room "Baldy 21" days "MR" time (10.30 11.30)))
             -->
             course=CSE-202
             semester="Summer 2004"
             room="Baldy 21"
             days="MR"
             time=(10.3 11.3)
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (print-properties '(course CSE-202 semester "Summer 2004"
                         room "Baldy 21" days "MR" time (10.30 11.30)))
             -->
             course=CSE-202
             semester="Summer 2004"
             room="Baldy 21"
             days="MR"
             time=(10.3 11.3)
         #+END_EXAMPLE
       #+END_QUOTE

   30. The Reader Считыватель

       The standard entry point into the reader is the function
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_rd_rd.htm][read]].
       The function
       [[http://www.lispworks.com/reference/HyperSpec/Body/f_rd_fro.htm][read-from-string]]
       is also often convenient.

       Основной функцией ввода (чтения) является функция =read=.
       Кроме неё бывает удобна функция =read-from-string=.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-input-from-string (input-stream "(a b c)")
               (read input-stream))

             (with-input-from-string (input-stream "5 (a b) 12.3 #\\c \"foo\" t")
               (loop repeat (read input-stream)
                 do (describe (read input-stream))))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-input-from-string (input-stream "(a b c)")
               (read input-stream))

             (with-input-from-string (input-stream "5 (a b) 12.3 #\\c \"foo\" t")
               (loop repeat (read input-stream)
                 do (describe (read input-stream))))
         #+END_EXAMPLE
       #+END_QUOTE

       Below is a reader function for the property list format we used
       above.
       
       Ниже представлена функция чтения списка свойств в том формате,
       в котором мы сделали вывод в прошлом разделе.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun read-properties (&optional (input-stream *standard-input*))
               "Reads a property list from INPUT-STREAM.
             The input should have one property-value pair on each line,
             in the form PROPERTY-NAME=VALUE.  The PROPERTY-NAME should
             be a Lisp symbol.  The VALUE may be any readable Lisp value."
               (loop for line = (read-line input-stream nil nil)
                 while line
                 for pos = (position #\= line)
                 unless pos do (error "bad property list format ~s" line)
                 collect (read-from-string line t nil :end pos)
                 collect (read-from-string line t nil :start (1+ pos))))

             (setf p1 '(course CSE-202 semester "Summer 2004"
                    room "Baldy 21" days "MR" time (10.30 11.30)))
             (setf p2 (with-output-to-string (stream)
                    (print-properties p1 stream)))
             (setf p3 (with-input-from-string (stream p2)
                        (read-properties stream)))
             (equal p1 p3)
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defun read-properties (&optional (input-stream *standard-input*))
               "Считывает список свойств из потока INPUT-STREAM.
             Входящие данные должны содержать пару свойство-значение каждое в отдельной строке
             в форме СВОЙСТВО=ЗНАЧЕНИЕ PROPERTY-NAME=VALUE.  СВОЙСТВО PROPERTY-NAME должно быть 
             Lisp'овым символ.  ЗНАЧЕНИЕ VALUE может быть любым читабельным объектом."
               (loop for line = (read-line input-stream nil nil)
                 while line
                 for pos = (position #\= line)
                 unless pos do (error "bad property list format ~s" line)
                 collect (read-from-string line t nil :end pos)
                 collect (read-from-string line t nil :start (1+ pos))))

             (setf p1 '(course CSE-202 semester "Summer 2004"
                    room "Baldy 21" days "MR" time (10.30 11.30)))
             (setf p2 (with-output-to-string (stream)
                    (print-properties p1 stream)))
             (setf p3 (with-input-from-string (stream p2)
                        (read-properties stream)))
             (equal p1 p3)
         #+END_EXAMPLE
       #+END_QUOTE

       In practice, we might want more error checking, because
       =read-properties= happily accepts input like:

       На практике, мы можем захотеть больше проверок на ошибки,
       потому что =read-properties= прекрасно принимает такой ввод:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-input-from-string (stream "hello world = 1 2 3")
               (read-properties stream))
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (with-input-from-string (stream "привет мир = 1 2 3")
               (read-properties stream))
         #+END_EXAMPLE
       #+END_QUOTE

       However, this entire example is a bit contrived, since if you
       wanted to store a property list or association list in a file
       (e.g., as a config file for your application), you would simply
       write the entire list to the file instead of formatting the data
       in some unreadable way. Then you could simply use the Lisp reader
       to reconstruct the entire list.

       Однако, этот весь пример немного выдуманный, тогда как если вы
       хотите сохранить список свойств или ассоциированный список в
       файле (например, конфигурационном файла для вашего
       приложения), вы можете просто написать готовый список в файл
       вместо форматирования его данных. Тогда вы и из файла можете
       просто прочесть список с конфигурацией.

       We will be able to work more meaningful exercises of printing and
       reading after we talk about Lisp "objects" -- that is, class
       instances. Since instances do not have a readable print syntax of
       their own, a common task is to concoct a readable syntax using
       readable objects such as lists so that instances can be written
       out to files and read back in. For now, the following exercise is
       hopefully a little more meaningful than the property list
       example.

       Теперь следующее упражнение будет более осмысленным, чем
       пример со списком свойств.

       Exercise: We decide to use a space-efficient file format for
       large, sparse arrays. The format is:
       =dimensions default-value index1 value1 index2 value2 ...=.
       For example:

       Управжнение: Мы решили использовать компактный формат файла
       для больших, разряжённых массивов. Формат такой:
       =dimensions default-value index1 value1 index2 value2 ...=.
       Например:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (100 100) 0
             (30 30) 30
             (60 60) 60
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (100 100) 0
             (30 30) 30
             (60 60) 60
         #+END_EXAMPLE
       #+END_QUOTE

       Write a function
       =(read-sparse-array &optional input-stream)= to read the
       sparse array format and construct the array.

       Напишите функцию =(read-sparse-array &optional input-stream)=
       для чтения данного формата и создания массива.

       Mini-Project: Write an outline formatter. Assume that the input
       is a sequence of lines; each line begins with /n/ spaces (/n/ ≥
       0) to indicated that it is a heading at outline level /n/. For
       example, here is an outline of the lecture notes on I/O:

       Небольшой проект: Напишите форматировщик
       оглавления. Предположим, что ввод это последовательность
       строк, каждая строка начинается с /n/-ного количество пробелов
       (/n/ ≥ 0), /n/ обозначает уровень данного заголовка. Например,
       вот оглавление для данного руководства для ввода/вывода:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             Input/output
              Streams
               File streams
               String streams
              Stream input and output functions
              Other stream functions
             The printer
              Print functions
              Format
               Destinations
               Control directives
               Examples
             The reader
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             Input/output
              Streams
               File streams
               String streams
              Stream input and output functions
              Other stream functions
             The printer
              Print functions
              Format
               Destinations
               Control directives
               Examples
             The reader
         #+END_EXAMPLE
       #+END_QUOTE

       Read an outline from an input stream, automatically number and
       indent it, and print it to an output stream. Below is one
       possible output format.

       Прочтите оглавление из потока ввода, пронумеруйте его,
       правильно расставьте отступы и напечатайте в поток
       вывода. Ниже представлен один из возможных форматов.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
                I. Input/output
                    A. Streams
                        1. File streams
                        2. String streams
                    B. Stream input and output functions
                    C. Other stream functions
               II. The printer
                    A. Print functions
                    B. Format
                        1. Destinations
                        2. Control directives
                        3. Examples
              III. The reader
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
                I. Input/output
                    A. Streams
                        1. File streams
                        2. String streams
                    B. Stream input and output functions
                    C. Other stream functions
               II. The printer
                    A. Print functions
                    B. Format
                        1. Destinations
                        2. Control directives
                        3. Examples
              III. The reader
         #+END_EXAMPLE
       #+END_QUOTE

       Your outline formatter should be guided by an outline format
       containing a list (/F/_{0} /F/_{1} ...). Each /F_{n}/ is a list
       of the form (/width/ /labeler/), where /width/ is the width of a
       label at outline level /n/ and /labeler/ is a function that takes
       a whole number and returns a label string in the style of level
       /n/. For example, the outline above was formatted using an
       outline format that begins as follows:

       Ваш форматтер для оглавления должен использовать список
       (/F/_{0} /F/_{1} ...). Каждый элемент /F_{n}/ представляет
       собой список вида (/width/ /labeler/), где /width/ это ширина
       отметки для названия уровня /n/ и /labeler/ это функция,
       которая принимает число, и возвращает строку для отметки уровня
       /n/. Например, оглавление выше было отформатированно с помощью
       следующего списка:

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defparameter *outline-format-1*
                 (list
                  (list 6 #'(lambda (n) (format nil "~@R." n)))
                  ...
         #+END_EXAMPLE
       #+END_QUOTE

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             (defparameter *outline-format-1*
                 (list
                  (list 6 #'(lambda (n) (format nil "~@R." n)))
                  ...
         #+END_EXAMPLE
       #+END_QUOTE

       Labels of level 0 are 6 characters wide, and the labeler function
       produces the roman numeral labels shown above. I'll leave it to
       you to determine what the rest of the entries should be to
       produce the rest of output shown above.

       Метки нулевого уровня имеют ширину в шесть символов, и функция
       для отметок возвращает римскую цифру. Автор предлагает вам
       самим додумать, каким должен быть весь список для форматтера.

       First, write a function
       =(read-outline &optional input-stream)= that reads the
       indented outline and constructs a list of the all the lines and
       their level.

       Сначала, напишите функцию =(read-outline &optional
       input-stream)=, которая читает план с отступами и создаёт
       список со всеми строками и их уровнями.

       #+BEGIN_QUOTE
         #+BEGIN_EXAMPLE
             ((0 "Input/output")
              (1 "Streams")
              (2 "File streams")
              (2 "String streams")
              (1 "Stream input and output functions")
              (1 "Other stream functions")
              (0 "The printer")
              (1 "Print functions")
              (1 "Format")
              (2 "Destinations")
              (2 "Control directives")
              (2 "Examples")
              (0 "The reader"))
         #+END_EXAMPLE
       #+END_QUOTE

       Second, write a function
       =(print-outline outline outline-format &optional output-stream)=
       to format this list according to /outline-format/.

       Затем напишите функцию =(print-outline outline outline-format
       &optional output-stream)= для форматирования данного списка в
       соответствие с форматом /outline-format/.

   31. CLOS Объектная система Common Lisp'а (CLOS)
       -  Introduction  :: The *C*ommon *L*isp *O*bject *S*ystem (see
                           the Common Lisp HyperSpec Chapter on
                           [[http://www.lispworks.com/reference/HyperSpec/Body/07_.htm][Objects]]) provides for the definition of
                           classes (with multiple inheritance) and
                           generic (polymorphic) functions.

          We are only going to give a simplified introduction to CLOS.
                           There are many details we will not cover.

          Many (but not all) predefined Common Lisp types are also
                           predefined classes. These are:
                           [[UB%20Lisp_files/classes.gif]] (Find the two
                           classes with multiple parents.)

          For a complete dag of the predefined classes available in
                           ACL, select the menu item

          =ACL=>Composer=>Start Composer=

          and then select the menu item

          =ACL=>Composer=>CLOS=>Show class subclasses=

          and enter =t= in the minibuffer.

       -  Введение :: Объектная система Common Lisp'а (CLOS) позволяет
                      создавать классы (с множественным наследованием)
                      и обобщённые (полиморфные) функции.

                      Авторы дадут только упрощённое введение в
                      CLOS. Много деталей останется за кадром.

                      Многие (но не все) стандартные Common Lisp'овые
                      типы также являются классами. Вот они:
                      UB%20Lisp_files/classes.gif (Найдите два класса
                      с несколькими родителями.)

                      

       -   Generic Functions :: A generic function is a collection of methods with the
          same name, and "congruent" (compatible) lambda lists
          (approximately: the same number of each kind of parameter; see
          the Hyperspec
          [[http://www.lispworks.com/reference/HyperSpec/Body/07_fd.htm][Chap. 7.6.4]] for all the details), but required parameters may
          specify the class of their actual arguments.

          Example 1: Let's define a generic function that will cause
          some Lisp objects to identify their class:

            Обобщённые функции :: Обобщённая функция это набор
            методов с одинаковыми именами и "совместимыми"
            лямбда-списками, при этом обязательные параметры могут
            указывать на класс для их аргументов.

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defmethod id ((x number))
                    "Prints a message identifying numbers."
                    "I'm a number.")

                (defmethod id ((x sequence))
                    "Prints a message identifying sequences."
                    "I'm a sequence.")
            #+END_EXAMPLE
          #+END_QUOTE

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defmethod id ((x number))
                    "Выводит сообщение о том, что это число."
                    "Я число.")

                (defmethod id ((x sequence))
                    "Выводит сообщение о том, что это последовательность."
                    "Я последовательность.")
            #+END_EXAMPLE
          #+END_QUOTE

          Test id for several numbers and sequences of different
          subtypes.
           Test id for several objects that are neither numbers nor
          sequences.

            Протестируйте =id= для нескольких чисел и
            последовательностей с разными подтипами.
            
          Протестируйте =id= для нескольких объектов, не чисел и
            не последовательностей.

          As you would expect, the applicable method for the lowest
          possible class is the one that is used.
           Exercise: add an =id= method for some subclass of number or
          sequence, and test that it is used when appropriate.

            Применяемый метод выбирается для самого нижнего возможного
            класса.
            Упражнение: добавьте метод =id= для некоторых подклассов
            числа (number) или последовательности (sequence), и
            протестируйте, что они используются в подходящих случаях.

          When a class /C / has two parent classes, and there is a
          generic function with a method for each one, which one is
          used? That is determined by /C/'s *class precedence list*. To
          see the class precedence list of some class, select the menu
          item

            Когда класс /C/ имеет два родительских класса, и
            существует метод для каждого из родителей, какой же из
            них будет использован? Это определяется с помощью *списка
            предшествующих классов* для /C/. 

          =ACL=>Composer=>CLOS=>Inspect class=

          and enter the name of the class in the minibuffer.

          Exercise: Find a class /C / in the above dag that has two
          parent classes. Define an =id= method for each parent class.
          Which method is used for an object of class /C/? Inspect class
          /C/, and check that its class precedence list is used
          correctly.

          Example 2: Define a =<= relation among numbers and symbols, so
          that lists containing mixed numbers and symbols may be ordered
          lexicographically. Numbers should be ordered by =cl:<=,
          symbols by =string<=, and any number should be =<= than any
          symbol.
           Solution:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defpackage :closExercises
                  (:shadow cl:<))

                (in-package :closExercises)

                (defmethod < ((n1 number) (n2 number))
                  "Returns t if the number n1 is less than the number n2; else nil."
                  (cl:< n1 n2))

                (defmethod < ((s1 symbol) (s2 symbol))
                  "Returns t if the symbol s1 is less than the symbol s2; else nil."
                  (string< s1 s2))

                (defmethod < ((n number) (s symbol))
                  "Returns t, because numbers are less than symbols."
                  t)

                (defmethod < ((s symbol) (n number))
                  "Returns nil, because symbols are not less than numbers."
                  nil)

                (defmethod < ((list1 list) (list2 list))
                  "Returns t if list1 is less than list2; nil otherwise."
                  ;; Lists are ordered lexicographically according to their members.
                  (cond
                   ((endp list1) list2)
                   ((endp list2) nil)
                   ((< (first list1) (first list2)) t)
                   ((< (first list2) (first list1)) nil)
                   (t (< (rest list1) (rest list2)))))
            #+END_EXAMPLE

            Exercise: Test this.
          #+END_QUOTE

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defpackage :closExercises
                  (:shadow cl:<))

                (in-package :closExercises)

                (defmethod < ((n1 number) (n2 number))
                  "Если число n1 меньше чем n2 возвращает t, иначе nil."
                  (cl:< n1 n2))

                (defmethod < ((s1 symbol) (s2 symbol))
                  "Если символ s1 меньше чем s2 возвращает t, иначе nil."
                  (string< s1 s2))

                (defmethod < ((n number) (s symbol))
                  "Возвращает t, так как числа меньше символов."
                  t)

                (defmethod < ((s symbol) (n number))
                  "Возвращает nil, так как символы не меньше чисел."
                  nil)

                (defmethod < ((list1 list) (list2 list))
                  "Если список list1 меньше чем  list2 возвращает t, иначе nil."
                  ;; Списки упорядочиваются лексикографически в соответствие с их элементами.
                  (cond
                   ((endp list1) list2)
                   ((endp list2) nil)
                   ((< (first list1) (first list2)) t)
                   ((< (first list2) (first list1)) nil)
                   (t (< (rest list1) (rest list2)))))
            #+END_EXAMPLE

            Упражнение: Проверьте методы.
            Exercise: Test this.
          #+END_QUOTE

          A generic function may be used in the same ways a regular
          function is used. For example, we may define =>= as follows:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                ;;; First shadow cl:>.
                (shadow 'cl:>)

                ;;; Then define >.
                (defun > (x y)
                  "Returns t if x is greater than y; nil Otherwise."
                  (< y x))
            #+END_EXAMPLE
          #+END_QUOTE

          Обобщённые функции могут использоваться также как и
            обычные. Например, мы может определить =>= следующим
            образом:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                ;;; Сначала скрываем cl:>.
                (shadow 'cl:>)

                ;;; Затем создаём >.
                (defun > (x y)
                  "Если x больше y возвращает t, иначе nil."
                  (< y x))
            #+END_EXAMPLE
          #+END_QUOTE
            
          Notice that =>= automatically handles the same classes as =<=
          does.

          Заметьте, что =>= автоматически работает для тех же
            классов, для которых работает =<=.

          Now, let's redo =<= using =defgeneric= and adding strings and
          lists. Strings should sort after symbols; lists should sort
          after strings. That is, any number should be =<= any symbol,
          any symbol should be =<= any string, any string should be =<=
          any list, numbers should be ordered by =cl:<=, symbols and
          strings should be ordered by =string<=, and lists should be
          ordered as shown above. (Do we really need to write 16
          different methods?)
           Solution:

          Теперь давайте сделаем =<= с помощью =defgeneric= и добавим
            строки и списки. Списки должны ставиться после символов,
            списки должны быть после строк. То есть, любое число =<=
            любого символа, любой символ =<= любой строки, и любая
            строка =<= любого списка, числа должны сравниваться
            с помощью =cl:<=, символы и строки -- с помощью =string<= и
            списки так, как показано ниже. (Нам действительно нужно
            писуть 16 различных методов?)
            Решение:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defpackage :closExercises
                  (:shadow cl:< cl:>))

                (in-package :closExercises)

                (defgeneric < (obj1 obj2)
                  (:documentation "Returns t if obj1 sorts as less than obj2; nil otherwise.")

                  (:method ((n1 number) (n2 number))
                       "Returns t if the number n1 is less than the number n2
                                      using cl:<; else nil."
                       (cl:< n1 n2))

                  (:method ((s1 symbol) (s2 symbol))
                       "Returns t if the symbol s1 is less than the symbol s2
                                      using string<; else nil."
                       (string< s1 s2))
                  
                  (:method ((s1 string) (s2 string))
                       "Returns t if the string s1 is less than the string s2
                                      using string<; else nil."
                       (string< s1 s2))

                  (:method ((list1 list) (list2 list))
                       "Returns t if list1 is lexicographically less than list2; nil otherwise."
                       ;; Lists are ordered lexicographically according to their members.
                       (cond
                        ((endp list1) list2)
                        ((endp list2) nil)
                        ((< (first list1) (first list2)) t)
                        ((< (first list2) (first list1)) nil)
                        (t (< (rest list1) (rest list2)))))
                  
                  (:method ((obj1 t) (obj2 t))
                       "Returns t if ojb1 is less than obj2 according to their types."
                       (check-type obj1 (or number symbol string list))
                       (check-type obj2 (or number symbol string list))
                       (member obj2
                           (member obj1 '(number symbol string list) :test #'typep)
                           :test #'typep)))

                (defun > (x y)
                  "Returns t if x is greater than y; nil Otherwise."
                  (< y x))
            #+END_EXAMPLE

            New concept:
            [[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/check-ty.htm][=check-type=]].

            Exercises:

            1. Test this.

            2. Add characters, to sort between numbers and symbols, and,
               among themselves using =char<=.
          #+END_QUOTE

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defpackage :closExercises
                  (:shadow cl:< cl:>))

                (in-package :closExercises)

                (defgeneric < (obj1 obj2)
                  (:documentation "Если объект obj1 меньше чем объект obj2 возвращает t, иначе nil.")

                  (:method ((n1 number) (n2 number))
                       "Если число n1 меньше чем число n2 возвращает t, иначе nil. Использует cl:<."
                       (cl:< n1 n2))

                  (:method ((s1 symbol) (s2 symbol))
                       "Если символ s1 меньше чем символ s2 возвращает t, иначе nil. Использует string<."
                       (string< s1 s2))
                  
                  (:method ((s1 string) (s2 string))
                       "Если строка s1 меньше чем строка s2 возвращает t, иначе nil. Использует string<."
                       (string< s1 s2))

                  (:method ((list1 list) (list2 list))
                       "Если список list1 лексикографически меньше чем список list2 возвращает t, иначе nil."
                       ;; Списки упорядочиваются лексикографически в соответствие с их элементами
                       (cond
                        ((endp list1) list2)
                        ((endp list2) nil)
                        ((< (first list1) (first list2)) t)
                        ((< (first list2) (first list1)) nil)
                        (t (< (rest list1) (rest list2)))))
                  
                  (:method ((obj1 t) (obj2 t))
                       "Если объект obj1 меньше чем объект obj2 возвращает t, учитывает сравнение разных типов."
                       (check-type obj1 (or number symbol string list))
                       (check-type obj2 (or number symbol string list))
                       (member obj2
                           (member obj1 '(number symbol string list) :test #'typep)
                           :test #'typep)))

                (defun > (x y)
                  "Если x больше чем y возвращает t, иначе nil."
                  (< y x))
            #+END_EXAMPLE

            New concept:
            [[http://www.franz.com/support/documentation/8.1/ansicl/dictentr/check-ty.htm][=check-type=]].

            Exercises:

            1. Test this.

            2. Add characters, to sort between numbers and symbols, and,
               among themselves using =char<=.

            Новая форма:
            =check-type=.

            Упражнения:

            1. Протестируйте то, что написали.

            2. Добавьте строковые символы, которые ставятся между
               числами и символами и сравниваются с помощью =<=.

          #+END_QUOTE

       -  Classes  :: An object (an instance of a class) is created by
                      =(make-instance class ...)=.

       -  Классы  :: Объекты (экземпляры класса) создаются с помощью 
                     =(make-instance class ...)=.

                     CLOS classes are defined by use of the macro
                     [[http://www.lispworks.com/reference/HyperSpec/Body/m_defcla.htm#defclass][defclass]]. (See also the HyperSpec chapter on [[http://www.lispworks.com/reference/HyperSpec/Body/04_cb.htm][Defining Classes]].)
                     
                     CLOS классы создаются с помощью =defclass=.
                     
                     A class may have up to three class-options, the only one of
                     which we will use is =:documentation=.
                     
                     Класс может иметь три специальные опции, мы будем
                     использовать только одну =:documentation=.
                     
                     A class may also have a set of slots, each of which has a
                     number of attributes specified by slot-options, which are:
                     
                     Класс также может содержать набор слотов, каждый
                     из которых имеет свойства, которые были заданы в
                     параметрах слота. Вот эти параметры:

          -  =:documentation= A documentation string.

          -  =:documentation= Строка документации.

          -  =:allocation= Either =:instance=, meaning that this is a
             slot local to each instance, or =:class=, meaning that this
             slot is shared among instances.

          -  =:allocation= Значение =:instance= означает, что этот слот
             локальный для каждого экземпляра, значение =:class=
             означает, что слот один для всех экземпляров класса.

          -  =:initarg= A symbol used like a keyword in =make-instance=
             to provide the value of this slot.

          -  =:initarg= Символ, который потом используется в
             =make-instance= для задания значения для слота.

          -  =:initform= A form, evaluated when each instance is
             created, to give the value for this slot.

          -  =:initform= Форма, которая вычисляется при создании
             экземпляра, и возвращает значения для слота.

          -  =:reader= A symbol which is made the name of a method used
             to get the value of this slot for each instance.

          -  =:reader= Символ, которые задаёт имя метода, который
             возвращает значение слота для заданного экземпляра.

          -  =:writer= A symbol which is made the name of a method used
             to set the value of this slot for each instance. If
             =setSlot= is the symbol, it is used by evaluating
             =(setSlot value instance)=

          -  =:writer= Символ, который задаёт имя для метода, который
             используется для установки значения в слот
             экземпляра. Если =setSlot= является символом, то
             итоговая форма выглядит так =(setSlot value instance)=

          -  =:accessor= A symbol which is made the name of a =setf=able
             method used to get or set the value of this slot for each
             instance.

          -  =:accessor= Символ, которые задаёт имя для метода,
             который используется и для чтения и для установки
             значения в слот экземпляра.

          -  =:type= The permitted type of values of this slot. ACL
             seems not to enforce this.

          -  =:type= Тип данных разрешённых в слоте.

          Even if neither a =:writer= nor an =:accessor= is provided for
          a slot, one my set or change the value of a slot by evaluating

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (setf (slot-value object slot-name) value)
            #+END_EXAMPLE
          #+END_QUOTE

          Даже если ни =:write=, ни =:accessor= не были указаны
                     значение слота можно получить или изменить с
                     помощью =slot-value=. Например:

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (setf (slot-value object slot-name) value)
            #+END_EXAMPLE
          #+END_QUOTE

          One may use

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defmethod initialize-instance :after ((object class) &rest args)
                    ...)
            #+END_EXAMPLE
          #+END_QUOTE

          to cause the initialization of some slots of an instance after
          the slots specified by =:initarg= and =:initform= have been
          set.

          Можно использовать 

          #+BEGIN_QUOTE
            #+BEGIN_EXAMPLE
                (defmethod initialize-instance :after ((object class) &rest args)
                    ...)
            #+END_EXAMPLE
          #+END_QUOTE

          это позволит инициализировать слоты после того как были
                     заданы =:initarg= и =:initform=.

          As an example, we will define some classes of weighable solids
          and a class of scales on which to weigh them. These are
          defined in the file
          [[http://www.cse.buffalo.edu/%7Eshapiro/Courses/CSE202/Summer2004/solids.cl][solids.cl]].

          В качестве пример, мы создадим классы для
                     взвешиваемых твёрдых веществ и класс для
                     весов. Они определены в файле solids.cl.

          Exercises:

          1. Copy
             [[http://www.cse.buffalo.edu/%7Eshapiro/Courses/CSE202/Summer2004/solids.cl][solids.cl]]
             into a file and test it.

          2. Use Composer's inspector to inspect the scale and some of
             the objects on it.

          3. Add a slot to the class of scales that is a list of the
             objects on the scale. Make sure that it is properly
             maintained.

          4. Add a method, =(removeObject scale object)= to remove an
             object from a scale. All slots should be maintained
             properly, but =removeObject= should cause an error if the
             object to be removed is not on the scale.

          5. Again use Composer's inspector to inspect a scale with some
             objects on it. Note that left-clicking on an object will
             cause Composer to bring up an inspector window on that
             object.

          Упражнения:

          1. Скопируйте solids.cl в свой файл и протестируйте его.

          2. Добавьте слот в класс весов, 
          
          3. Добавьте метод =(removeObject scale object)= для
             убирания объекта с весов. Все слоты должны быть
             правильно настроены, а =removeObject= должен
             сигнализировать ошибку, если объект для убирания не
             находится на весах.

Copyright © 2004 by Stuart C. Shapiro & David R. Pierce. All rights
reserved.

--------------

[[http://www.cse.buffalo.edu/%7Eshapiro/][Stuart C. Shapiro]] <[[mailto:shapiro@cse.buffalo.edu?subject=Lisp%20course][shapiro at cse.buffalo.edu]]>

[[http://www.cse.buffalo.edu/%7Edrpierce/][David R. Pierce]] <drpierce at cse.buffalo.edu>

Last modified: Thu Feb 4 11:37:30 EST 2010

